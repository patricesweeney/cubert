"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tough-cookie";
exports.ids = ["vendor-chunks/tough-cookie"];
exports.modules = {

/***/ "(ssr)/./node_modules/tough-cookie/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/tough-cookie/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cookie: () => (/* binding */ Cookie),\n/* harmony export */   CookieJar: () => (/* binding */ CookieJar),\n/* harmony export */   MemoryCookieStore: () => (/* binding */ MemoryCookieStore),\n/* harmony export */   ParameterError: () => (/* binding */ ParameterError),\n/* harmony export */   PrefixSecurityEnum: () => (/* binding */ PrefixSecurityEnum),\n/* harmony export */   Store: () => (/* binding */ Store),\n/* harmony export */   canonicalDomain: () => (/* binding */ canonicalDomain),\n/* harmony export */   cookieCompare: () => (/* binding */ cookieCompare),\n/* harmony export */   defaultPath: () => (/* binding */ defaultPath),\n/* harmony export */   domainMatch: () => (/* binding */ domainMatch),\n/* harmony export */   formatDate: () => (/* binding */ formatDate),\n/* harmony export */   fromJSON: () => (/* binding */ fromJSON2),\n/* harmony export */   getPublicSuffix: () => (/* binding */ getPublicSuffix),\n/* harmony export */   parse: () => (/* binding */ parse2),\n/* harmony export */   parseDate: () => (/* binding */ parseDate),\n/* harmony export */   pathMatch: () => (/* binding */ pathMatch),\n/* harmony export */   permuteDomain: () => (/* binding */ permuteDomain),\n/* harmony export */   permutePath: () => (/* binding */ permutePath),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var tldts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tldts */ \"(ssr)/./node_modules/tldts/dist/es6/index.js\");\n// lib/pathMatch.ts\nfunction pathMatch(reqPath, cookiePath) {\n  if (cookiePath === reqPath) {\n    return true;\n  }\n  const idx = reqPath.indexOf(cookiePath);\n  if (idx === 0) {\n    if (cookiePath[cookiePath.length - 1] === \"/\") {\n      return true;\n    }\n    if (reqPath.startsWith(cookiePath) && reqPath[cookiePath.length] === \"/\") {\n      return true;\n    }\n  }\n  return false;\n}\n\n// lib/getPublicSuffix.ts\n\nvar SPECIAL_USE_DOMAINS = [\"local\", \"example\", \"invalid\", \"localhost\", \"test\"];\nvar SPECIAL_TREATMENT_DOMAINS = [\"localhost\", \"invalid\"];\nvar defaultGetPublicSuffixOptions = {\n  allowSpecialUseDomain: false,\n  ignoreError: false\n};\nfunction getPublicSuffix(domain, options = {}) {\n  options = { ...defaultGetPublicSuffixOptions, ...options };\n  const domainParts = domain.split(\".\");\n  const topLevelDomain = domainParts[domainParts.length - 1];\n  const allowSpecialUseDomain = !!options.allowSpecialUseDomain;\n  const ignoreError = !!options.ignoreError;\n  if (allowSpecialUseDomain && topLevelDomain !== void 0 && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {\n    if (domainParts.length > 1) {\n      const secondLevelDomain = domainParts[domainParts.length - 2];\n      return `${secondLevelDomain}.${topLevelDomain}`;\n    } else if (SPECIAL_TREATMENT_DOMAINS.includes(topLevelDomain)) {\n      return topLevelDomain;\n    }\n  }\n  if (!ignoreError && topLevelDomain !== void 0 && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {\n    throw new Error(\n      `Cookie has domain set to the public suffix \"${topLevelDomain}\" which is a special use domain. To allow this, configure your CookieJar with {allowSpecialUseDomain: true, rejectPublicSuffixes: false}.`\n    );\n  }\n  const publicSuffix = (0,tldts__WEBPACK_IMPORTED_MODULE_0__.getDomain)(domain, {\n    allowIcannDomains: true,\n    allowPrivateDomains: true\n  });\n  if (publicSuffix) return publicSuffix;\n}\n\n// lib/permuteDomain.ts\nfunction permuteDomain(domain, allowSpecialUseDomain) {\n  const pubSuf = getPublicSuffix(domain, {\n    allowSpecialUseDomain\n  });\n  if (!pubSuf) {\n    return void 0;\n  }\n  if (pubSuf == domain) {\n    return [domain];\n  }\n  if (domain.slice(-1) == \".\") {\n    domain = domain.slice(0, -1);\n  }\n  const prefix = domain.slice(0, -(pubSuf.length + 1));\n  const parts = prefix.split(\".\").reverse();\n  let cur = pubSuf;\n  const permutations = [cur];\n  while (parts.length) {\n    const part = parts.shift();\n    cur = `${part}.${cur}`;\n    permutations.push(cur);\n  }\n  return permutations;\n}\n\n// lib/store.ts\nvar Store = class {\n  constructor() {\n    this.synchronous = false;\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  findCookie(_domain, _path, _key, _callback) {\n    throw new Error(\"findCookie is not implemented\");\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  findCookies(_domain, _path, _allowSpecialUseDomain = false, _callback) {\n    throw new Error(\"findCookies is not implemented\");\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  putCookie(_cookie, _callback) {\n    throw new Error(\"putCookie is not implemented\");\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  updateCookie(_oldCookie, _newCookie, _callback) {\n    throw new Error(\"updateCookie is not implemented\");\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  removeCookie(_domain, _path, _key, _callback) {\n    throw new Error(\"removeCookie is not implemented\");\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  removeCookies(_domain, _path, _callback) {\n    throw new Error(\"removeCookies is not implemented\");\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  removeAllCookies(_callback) {\n    throw new Error(\"removeAllCookies is not implemented\");\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  getAllCookies(_callback) {\n    throw new Error(\n      \"getAllCookies is not implemented (therefore jar cannot be serialized)\"\n    );\n  }\n};\n\n// lib/utils.ts\nvar objectToString = (obj) => Object.prototype.toString.call(obj);\nvar safeArrayToString = (arr, seenArrays) => {\n  if (typeof arr.join !== \"function\") return objectToString(arr);\n  seenArrays.add(arr);\n  const mapped = arr.map(\n    (val) => val === null || val === void 0 || seenArrays.has(val) ? \"\" : safeToStringImpl(val, seenArrays)\n  );\n  return mapped.join();\n};\nvar safeToStringImpl = (val, seenArrays = /* @__PURE__ */ new WeakSet()) => {\n  if (typeof val !== \"object\" || val === null) {\n    return String(val);\n  } else if (typeof val.toString === \"function\") {\n    return Array.isArray(val) ? (\n      // Arrays have a weird custom toString that we need to replicate\n      safeArrayToString(val, seenArrays)\n    ) : (\n      // eslint-disable-next-line @typescript-eslint/no-base-to-string\n      String(val)\n    );\n  } else {\n    return objectToString(val);\n  }\n};\nvar safeToString = (val) => safeToStringImpl(val);\nfunction createPromiseCallback(cb) {\n  let callback;\n  let resolve;\n  let reject;\n  const promise = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  if (typeof cb === \"function\") {\n    callback = (err, result) => {\n      try {\n        if (err) cb(err);\n        else cb(null, result);\n      } catch (e) {\n        reject(e instanceof Error ? e : new Error());\n      }\n    };\n  } else {\n    callback = (err, result) => {\n      try {\n        if (err) reject(err);\n        else resolve(result);\n      } catch (e) {\n        reject(e instanceof Error ? e : new Error());\n      }\n    };\n  }\n  return {\n    promise,\n    callback,\n    resolve: (value) => {\n      callback(null, value);\n      return promise;\n    },\n    reject: (error) => {\n      callback(error);\n      return promise;\n    }\n  };\n}\nfunction inOperator(k, o) {\n  return k in o;\n}\n\n// lib/memstore.ts\nvar MemoryCookieStore = class extends Store {\n  /**\n   * Create a new {@link MemoryCookieStore}.\n   */\n  constructor() {\n    super();\n    this.synchronous = true;\n    this.idx = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  findCookie(domain, path, key, callback) {\n    const promiseCallback = createPromiseCallback(callback);\n    if (domain == null || path == null || key == null) {\n      return promiseCallback.resolve(void 0);\n    }\n    const result = this.idx[domain]?.[path]?.[key];\n    return promiseCallback.resolve(result);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  findCookies(domain, path, allowSpecialUseDomain = false, callback) {\n    if (typeof allowSpecialUseDomain === \"function\") {\n      callback = allowSpecialUseDomain;\n      allowSpecialUseDomain = true;\n    }\n    const results = [];\n    const promiseCallback = createPromiseCallback(callback);\n    if (!domain) {\n      return promiseCallback.resolve([]);\n    }\n    let pathMatcher;\n    if (!path) {\n      pathMatcher = function matchAll(domainIndex) {\n        for (const curPath in domainIndex) {\n          const pathIndex = domainIndex[curPath];\n          for (const key in pathIndex) {\n            const value = pathIndex[key];\n            if (value) {\n              results.push(value);\n            }\n          }\n        }\n      };\n    } else {\n      pathMatcher = function matchRFC(domainIndex) {\n        for (const cookiePath in domainIndex) {\n          if (pathMatch(path, cookiePath)) {\n            const pathIndex = domainIndex[cookiePath];\n            for (const key in pathIndex) {\n              const value = pathIndex[key];\n              if (value) {\n                results.push(value);\n              }\n            }\n          }\n        }\n      };\n    }\n    const domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];\n    const idx = this.idx;\n    domains.forEach((curDomain) => {\n      const domainIndex = idx[curDomain];\n      if (!domainIndex) {\n        return;\n      }\n      pathMatcher(domainIndex);\n    });\n    return promiseCallback.resolve(results);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  putCookie(cookie, callback) {\n    const promiseCallback = createPromiseCallback(callback);\n    const { domain, path, key } = cookie;\n    if (domain == null || path == null || key == null) {\n      return promiseCallback.resolve(void 0);\n    }\n    const domainEntry = this.idx[domain] ?? /* @__PURE__ */ Object.create(null);\n    this.idx[domain] = domainEntry;\n    const pathEntry = domainEntry[path] ?? /* @__PURE__ */ Object.create(null);\n    domainEntry[path] = pathEntry;\n    pathEntry[key] = cookie;\n    return promiseCallback.resolve(void 0);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  updateCookie(_oldCookie, newCookie, callback) {\n    if (callback) this.putCookie(newCookie, callback);\n    else return this.putCookie(newCookie);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  removeCookie(domain, path, key, callback) {\n    const promiseCallback = createPromiseCallback(callback);\n    delete this.idx[domain]?.[path]?.[key];\n    return promiseCallback.resolve(void 0);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  removeCookies(domain, path, callback) {\n    const promiseCallback = createPromiseCallback(callback);\n    const domainEntry = this.idx[domain];\n    if (domainEntry) {\n      if (path) {\n        delete domainEntry[path];\n      } else {\n        delete this.idx[domain];\n      }\n    }\n    return promiseCallback.resolve(void 0);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  removeAllCookies(callback) {\n    const promiseCallback = createPromiseCallback(callback);\n    this.idx = /* @__PURE__ */ Object.create(null);\n    return promiseCallback.resolve(void 0);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  getAllCookies(callback) {\n    const promiseCallback = createPromiseCallback(callback);\n    const cookies = [];\n    const idx = this.idx;\n    const domains = Object.keys(idx);\n    domains.forEach((domain) => {\n      const domainEntry = idx[domain] ?? {};\n      const paths = Object.keys(domainEntry);\n      paths.forEach((path) => {\n        const pathEntry = domainEntry[path] ?? {};\n        const keys = Object.keys(pathEntry);\n        keys.forEach((key) => {\n          const keyEntry = pathEntry[key];\n          if (keyEntry != null) {\n            cookies.push(keyEntry);\n          }\n        });\n      });\n    });\n    cookies.sort((a, b) => {\n      return (a.creationIndex || 0) - (b.creationIndex || 0);\n    });\n    return promiseCallback.resolve(cookies);\n  }\n};\n\n// lib/validators.ts\nfunction isNonEmptyString(data) {\n  return isString(data) && data !== \"\";\n}\nfunction isEmptyString(data) {\n  return data === \"\" || data instanceof String && data.toString() === \"\";\n}\nfunction isString(data) {\n  return typeof data === \"string\" || data instanceof String;\n}\nfunction isObject(data) {\n  return objectToString(data) === \"[object Object]\";\n}\nfunction validate(bool, cbOrMessage, message) {\n  if (bool) return;\n  const cb = typeof cbOrMessage === \"function\" ? cbOrMessage : void 0;\n  let options = typeof cbOrMessage === \"function\" ? message : cbOrMessage;\n  if (!isObject(options)) options = \"[object Object]\";\n  const err = new ParameterError(safeToString(options));\n  if (cb) cb(err);\n  else throw err;\n}\nvar ParameterError = class extends Error {\n};\n\n// lib/version.ts\nvar version = \"6.0.0\";\n\n// lib/cookie/constants.ts\nvar PrefixSecurityEnum = {\n  SILENT: \"silent\",\n  STRICT: \"strict\",\n  DISABLED: \"unsafe-disabled\"\n};\nObject.freeze(PrefixSecurityEnum);\nvar IP_V6_REGEX = `\n\\\\[?(?:\n(?:[a-fA-F\\\\d]{1,4}:){7}(?:[a-fA-F\\\\d]{1,4}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|:[a-fA-F\\\\d]{1,4}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,2}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){4}(?:(?::[a-fA-F\\\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,3}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){3}(?:(?::[a-fA-F\\\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,4}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){2}(?:(?::[a-fA-F\\\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,5}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){1}(?:(?::[a-fA-F\\\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,6}|:)|\n(?::(?:(?::[a-fA-F\\\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,7}|:))\n)(?:%[0-9a-zA-Z]{1,})?\\\\]?\n`.replace(/\\s*\\/\\/.*$/gm, \"\").replace(/\\n/g, \"\").trim();\nvar IP_V6_REGEX_OBJECT = new RegExp(`^${IP_V6_REGEX}$`);\nvar IP_V4_REGEX = `(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])`;\nvar IP_V4_REGEX_OBJECT = new RegExp(`^${IP_V4_REGEX}$`);\n\n// lib/cookie/canonicalDomain.ts\nfunction domainToASCII(domain) {\n  return new URL(`http://${domain}`).hostname;\n}\nfunction canonicalDomain(domainName) {\n  if (domainName == null) {\n    return void 0;\n  }\n  let str = domainName.trim().replace(/^\\./, \"\");\n  if (IP_V6_REGEX_OBJECT.test(str)) {\n    if (!str.startsWith(\"[\")) {\n      str = \"[\" + str;\n    }\n    if (!str.endsWith(\"]\")) {\n      str = str + \"]\";\n    }\n    return domainToASCII(str).slice(1, -1);\n  }\n  if (/[^\\u0001-\\u007f]/.test(str)) {\n    return domainToASCII(str);\n  }\n  return str.toLowerCase();\n}\n\n// lib/cookie/formatDate.ts\nfunction formatDate(date) {\n  return date.toUTCString();\n}\n\n// lib/cookie/parseDate.ts\nvar DATE_DELIM = /[\\x09\\x20-\\x2F\\x3B-\\x40\\x5B-\\x60\\x7B-\\x7E]/;\nvar MONTH_TO_NUM = {\n  jan: 0,\n  feb: 1,\n  mar: 2,\n  apr: 3,\n  may: 4,\n  jun: 5,\n  jul: 6,\n  aug: 7,\n  sep: 8,\n  oct: 9,\n  nov: 10,\n  dec: 11\n};\nfunction parseDigits(token, minDigits, maxDigits, trailingOK) {\n  let count = 0;\n  while (count < token.length) {\n    const c = token.charCodeAt(count);\n    if (c <= 47 || c >= 58) {\n      break;\n    }\n    count++;\n  }\n  if (count < minDigits || count > maxDigits) {\n    return;\n  }\n  if (!trailingOK && count != token.length) {\n    return;\n  }\n  return parseInt(token.slice(0, count), 10);\n}\nfunction parseTime(token) {\n  const parts = token.split(\":\");\n  const result = [0, 0, 0];\n  if (parts.length !== 3) {\n    return;\n  }\n  for (let i = 0; i < 3; i++) {\n    const trailingOK = i == 2;\n    const numPart = parts[i];\n    if (numPart === void 0) {\n      return;\n    }\n    const num = parseDigits(numPart, 1, 2, trailingOK);\n    if (num === void 0) {\n      return;\n    }\n    result[i] = num;\n  }\n  return result;\n}\nfunction parseMonth(token) {\n  token = String(token).slice(0, 3).toLowerCase();\n  switch (token) {\n    case \"jan\":\n      return MONTH_TO_NUM.jan;\n    case \"feb\":\n      return MONTH_TO_NUM.feb;\n    case \"mar\":\n      return MONTH_TO_NUM.mar;\n    case \"apr\":\n      return MONTH_TO_NUM.apr;\n    case \"may\":\n      return MONTH_TO_NUM.may;\n    case \"jun\":\n      return MONTH_TO_NUM.jun;\n    case \"jul\":\n      return MONTH_TO_NUM.jul;\n    case \"aug\":\n      return MONTH_TO_NUM.aug;\n    case \"sep\":\n      return MONTH_TO_NUM.sep;\n    case \"oct\":\n      return MONTH_TO_NUM.oct;\n    case \"nov\":\n      return MONTH_TO_NUM.nov;\n    case \"dec\":\n      return MONTH_TO_NUM.dec;\n    default:\n      return;\n  }\n}\nfunction parseDate(cookieDate) {\n  if (!cookieDate) {\n    return;\n  }\n  const tokens = cookieDate.split(DATE_DELIM);\n  let hour;\n  let minute;\n  let second;\n  let dayOfMonth;\n  let month;\n  let year;\n  for (let i = 0; i < tokens.length; i++) {\n    const token = (tokens[i] ?? \"\").trim();\n    if (!token.length) {\n      continue;\n    }\n    if (second === void 0) {\n      const result = parseTime(token);\n      if (result) {\n        hour = result[0];\n        minute = result[1];\n        second = result[2];\n        continue;\n      }\n    }\n    if (dayOfMonth === void 0) {\n      const result = parseDigits(token, 1, 2, true);\n      if (result !== void 0) {\n        dayOfMonth = result;\n        continue;\n      }\n    }\n    if (month === void 0) {\n      const result = parseMonth(token);\n      if (result !== void 0) {\n        month = result;\n        continue;\n      }\n    }\n    if (year === void 0) {\n      const result = parseDigits(token, 2, 4, true);\n      if (result !== void 0) {\n        year = result;\n        if (year >= 70 && year <= 99) {\n          year += 1900;\n        } else if (year >= 0 && year <= 69) {\n          year += 2e3;\n        }\n      }\n    }\n  }\n  if (dayOfMonth === void 0 || month === void 0 || year === void 0 || hour === void 0 || minute === void 0 || second === void 0 || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {\n    return;\n  }\n  return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));\n}\n\n// lib/cookie/cookie.ts\nvar COOKIE_OCTETS = /^[\\x21\\x23-\\x2B\\x2D-\\x3A\\x3C-\\x5B\\x5D-\\x7E]+$/;\nvar PATH_VALUE = /[\\x20-\\x3A\\x3C-\\x7E]+/;\nvar CONTROL_CHARS = /[\\x00-\\x1F]/;\nvar TERMINATORS = [\"\\n\", \"\\r\", \"\\0\"];\nfunction trimTerminator(str) {\n  if (isEmptyString(str)) return str;\n  for (let t = 0; t < TERMINATORS.length; t++) {\n    const terminator = TERMINATORS[t];\n    const terminatorIdx = terminator ? str.indexOf(terminator) : -1;\n    if (terminatorIdx !== -1) {\n      str = str.slice(0, terminatorIdx);\n    }\n  }\n  return str;\n}\nfunction parseCookiePair(cookiePair, looseMode) {\n  cookiePair = trimTerminator(cookiePair);\n  let firstEq = cookiePair.indexOf(\"=\");\n  if (looseMode) {\n    if (firstEq === 0) {\n      cookiePair = cookiePair.substring(1);\n      firstEq = cookiePair.indexOf(\"=\");\n    }\n  } else {\n    if (firstEq <= 0) {\n      return void 0;\n    }\n  }\n  let cookieName, cookieValue;\n  if (firstEq <= 0) {\n    cookieName = \"\";\n    cookieValue = cookiePair.trim();\n  } else {\n    cookieName = cookiePair.slice(0, firstEq).trim();\n    cookieValue = cookiePair.slice(firstEq + 1).trim();\n  }\n  if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {\n    return void 0;\n  }\n  const c = new Cookie();\n  c.key = cookieName;\n  c.value = cookieValue;\n  return c;\n}\nfunction parse(str, options) {\n  if (isEmptyString(str) || !isString(str)) {\n    return void 0;\n  }\n  str = str.trim();\n  const firstSemi = str.indexOf(\";\");\n  const cookiePair = firstSemi === -1 ? str : str.slice(0, firstSemi);\n  const c = parseCookiePair(cookiePair, options?.loose ?? false);\n  if (!c) {\n    return void 0;\n  }\n  if (firstSemi === -1) {\n    return c;\n  }\n  const unparsed = str.slice(firstSemi + 1).trim();\n  if (unparsed.length === 0) {\n    return c;\n  }\n  const cookie_avs = unparsed.split(\";\");\n  while (cookie_avs.length) {\n    const av = (cookie_avs.shift() ?? \"\").trim();\n    if (av.length === 0) {\n      continue;\n    }\n    const av_sep = av.indexOf(\"=\");\n    let av_key, av_value;\n    if (av_sep === -1) {\n      av_key = av;\n      av_value = null;\n    } else {\n      av_key = av.slice(0, av_sep);\n      av_value = av.slice(av_sep + 1);\n    }\n    av_key = av_key.trim().toLowerCase();\n    if (av_value) {\n      av_value = av_value.trim();\n    }\n    switch (av_key) {\n      case \"expires\":\n        if (av_value) {\n          const exp = parseDate(av_value);\n          if (exp) {\n            c.expires = exp;\n          }\n        }\n        break;\n      case \"max-age\":\n        if (av_value) {\n          if (/^-?[0-9]+$/.test(av_value)) {\n            const delta = parseInt(av_value, 10);\n            c.setMaxAge(delta);\n          }\n        }\n        break;\n      case \"domain\":\n        if (av_value) {\n          const domain = av_value.trim().replace(/^\\./, \"\");\n          if (domain) {\n            c.domain = domain.toLowerCase();\n          }\n        }\n        break;\n      case \"path\":\n        c.path = av_value && av_value[0] === \"/\" ? av_value : null;\n        break;\n      case \"secure\":\n        c.secure = true;\n        break;\n      case \"httponly\":\n        c.httpOnly = true;\n        break;\n      case \"samesite\":\n        switch (av_value ? av_value.toLowerCase() : \"\") {\n          case \"strict\":\n            c.sameSite = \"strict\";\n            break;\n          case \"lax\":\n            c.sameSite = \"lax\";\n            break;\n          case \"none\":\n            c.sameSite = \"none\";\n            break;\n          default:\n            c.sameSite = void 0;\n            break;\n        }\n        break;\n      default:\n        c.extensions = c.extensions || [];\n        c.extensions.push(av);\n        break;\n    }\n  }\n  return c;\n}\nfunction fromJSON(str) {\n  if (!str || isEmptyString(str)) {\n    return void 0;\n  }\n  let obj;\n  if (typeof str === \"string\") {\n    try {\n      obj = JSON.parse(str);\n    } catch {\n      return void 0;\n    }\n  } else {\n    obj = str;\n  }\n  const c = new Cookie();\n  Cookie.serializableProperties.forEach((prop) => {\n    if (obj && typeof obj === \"object\" && inOperator(prop, obj)) {\n      const val = obj[prop];\n      if (val === void 0) {\n        return;\n      }\n      if (inOperator(prop, cookieDefaults) && val === cookieDefaults[prop]) {\n        return;\n      }\n      switch (prop) {\n        case \"key\":\n        case \"value\":\n        case \"sameSite\":\n          if (typeof val === \"string\") {\n            c[prop] = val;\n          }\n          break;\n        case \"expires\":\n        case \"creation\":\n        case \"lastAccessed\":\n          if (typeof val === \"number\" || typeof val === \"string\" || val instanceof Date) {\n            c[prop] = obj[prop] == \"Infinity\" ? \"Infinity\" : new Date(val);\n          } else if (val === null) {\n            c[prop] = null;\n          }\n          break;\n        case \"maxAge\":\n          if (typeof val === \"number\" || val === \"Infinity\" || val === \"-Infinity\") {\n            c[prop] = val;\n          }\n          break;\n        case \"domain\":\n        case \"path\":\n          if (typeof val === \"string\" || val === null) {\n            c[prop] = val;\n          }\n          break;\n        case \"secure\":\n        case \"httpOnly\":\n          if (typeof val === \"boolean\") {\n            c[prop] = val;\n          }\n          break;\n        case \"extensions\":\n          if (Array.isArray(val) && val.every((item) => typeof item === \"string\")) {\n            c[prop] = val;\n          }\n          break;\n        case \"hostOnly\":\n        case \"pathIsDefault\":\n          if (typeof val === \"boolean\" || val === null) {\n            c[prop] = val;\n          }\n          break;\n      }\n    }\n  });\n  return c;\n}\nvar cookieDefaults = {\n  // the order in which the RFC has them:\n  key: \"\",\n  value: \"\",\n  expires: \"Infinity\",\n  maxAge: null,\n  domain: null,\n  path: null,\n  secure: false,\n  httpOnly: false,\n  extensions: null,\n  // set by the CookieJar:\n  hostOnly: null,\n  pathIsDefault: null,\n  creation: null,\n  lastAccessed: null,\n  sameSite: void 0\n};\nvar _Cookie = class _Cookie {\n  /**\n   * Create a new Cookie instance.\n   * @public\n   * @param options - The attributes to set on the cookie\n   */\n  constructor(options = {}) {\n    this.key = options.key ?? cookieDefaults.key;\n    this.value = options.value ?? cookieDefaults.value;\n    this.expires = options.expires ?? cookieDefaults.expires;\n    this.maxAge = options.maxAge ?? cookieDefaults.maxAge;\n    this.domain = options.domain ?? cookieDefaults.domain;\n    this.path = options.path ?? cookieDefaults.path;\n    this.secure = options.secure ?? cookieDefaults.secure;\n    this.httpOnly = options.httpOnly ?? cookieDefaults.httpOnly;\n    this.extensions = options.extensions ?? cookieDefaults.extensions;\n    this.creation = options.creation ?? cookieDefaults.creation;\n    this.hostOnly = options.hostOnly ?? cookieDefaults.hostOnly;\n    this.pathIsDefault = options.pathIsDefault ?? cookieDefaults.pathIsDefault;\n    this.lastAccessed = options.lastAccessed ?? cookieDefaults.lastAccessed;\n    this.sameSite = options.sameSite ?? cookieDefaults.sameSite;\n    this.creation = options.creation ?? /* @__PURE__ */ new Date();\n    Object.defineProperty(this, \"creationIndex\", {\n      configurable: false,\n      enumerable: false,\n      // important for assert.deepEqual checks\n      writable: true,\n      value: ++_Cookie.cookiesCreated\n    });\n    this.creationIndex = _Cookie.cookiesCreated;\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    const now = Date.now();\n    const hostOnly = this.hostOnly != null ? this.hostOnly.toString() : \"?\";\n    const createAge = this.creation && this.creation !== \"Infinity\" ? `${String(now - this.creation.getTime())}ms` : \"?\";\n    const accessAge = this.lastAccessed && this.lastAccessed !== \"Infinity\" ? `${String(now - this.lastAccessed.getTime())}ms` : \"?\";\n    return `Cookie=\"${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}\"`;\n  }\n  /**\n   * For convenience in using `JSON.stringify(cookie)`. Returns a plain-old Object that can be JSON-serialized.\n   *\n   * @remarks\n   * - Any `Date` properties (such as {@link Cookie.expires}, {@link Cookie.creation}, and {@link Cookie.lastAccessed}) are exported in ISO format (`Date.toISOString()`).\n   *\n   *  - Custom Cookie properties are discarded. In tough-cookie 1.x, since there was no {@link Cookie.toJSON} method explicitly defined, all enumerable properties were captured.\n   *      If you want a property to be serialized, add the property name to {@link Cookie.serializableProperties}.\n   */\n  toJSON() {\n    const obj = {};\n    for (const prop of _Cookie.serializableProperties) {\n      const val = this[prop];\n      if (val === cookieDefaults[prop]) {\n        continue;\n      }\n      switch (prop) {\n        case \"key\":\n        case \"value\":\n        case \"sameSite\":\n          if (typeof val === \"string\") {\n            obj[prop] = val;\n          }\n          break;\n        case \"expires\":\n        case \"creation\":\n        case \"lastAccessed\":\n          if (typeof val === \"number\" || typeof val === \"string\" || val instanceof Date) {\n            obj[prop] = val == \"Infinity\" ? \"Infinity\" : new Date(val).toISOString();\n          } else if (val === null) {\n            obj[prop] = null;\n          }\n          break;\n        case \"maxAge\":\n          if (typeof val === \"number\" || val === \"Infinity\" || val === \"-Infinity\") {\n            obj[prop] = val;\n          }\n          break;\n        case \"domain\":\n        case \"path\":\n          if (typeof val === \"string\" || val === null) {\n            obj[prop] = val;\n          }\n          break;\n        case \"secure\":\n        case \"httpOnly\":\n          if (typeof val === \"boolean\") {\n            obj[prop] = val;\n          }\n          break;\n        case \"extensions\":\n          if (Array.isArray(val)) {\n            obj[prop] = val;\n          }\n          break;\n        case \"hostOnly\":\n        case \"pathIsDefault\":\n          if (typeof val === \"boolean\" || val === null) {\n            obj[prop] = val;\n          }\n          break;\n      }\n    }\n    return obj;\n  }\n  /**\n   * Does a deep clone of this cookie, implemented exactly as `Cookie.fromJSON(cookie.toJSON())`.\n   * @public\n   */\n  clone() {\n    return fromJSON(this.toJSON());\n  }\n  /**\n   * Validates cookie attributes for semantic correctness. Useful for \"lint\" checking any `Set-Cookie` headers you generate.\n   * For now, it returns a boolean, but eventually could return a reason string.\n   *\n   * @remarks\n   * Works for a few things, but is by no means comprehensive.\n   *\n   * @beta\n   */\n  validate() {\n    if (!this.value || !COOKIE_OCTETS.test(this.value)) {\n      return false;\n    }\n    if (this.expires != \"Infinity\" && !(this.expires instanceof Date) && !parseDate(this.expires)) {\n      return false;\n    }\n    if (this.maxAge != null && this.maxAge !== \"Infinity\" && (this.maxAge === \"-Infinity\" || this.maxAge <= 0)) {\n      return false;\n    }\n    if (this.path != null && !PATH_VALUE.test(this.path)) {\n      return false;\n    }\n    const cdomain = this.cdomain();\n    if (cdomain) {\n      if (cdomain.match(/\\.$/)) {\n        return false;\n      }\n      const suffix = getPublicSuffix(cdomain);\n      if (suffix == null) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Sets the 'Expires' attribute on a cookie.\n   *\n   * @remarks\n   * When given a `string` value it will be parsed with {@link parseDate}. If the value can't be parsed as a cookie date\n   * then the 'Expires' attribute will be set to `\"Infinity\"`.\n   *\n   * @param exp - the new value for the 'Expires' attribute of the cookie.\n   */\n  setExpires(exp) {\n    if (exp instanceof Date) {\n      this.expires = exp;\n    } else {\n      this.expires = parseDate(exp) || \"Infinity\";\n    }\n  }\n  /**\n   * Sets the 'Max-Age' attribute (in seconds) on a cookie.\n   *\n   * @remarks\n   * Coerces `-Infinity` to `\"-Infinity\"` and `Infinity` to `\"Infinity\"` so it can be serialized to JSON.\n   *\n   * @param age - the new value for the 'Max-Age' attribute (in seconds).\n   */\n  setMaxAge(age) {\n    if (age === Infinity) {\n      this.maxAge = \"Infinity\";\n    } else if (age === -Infinity) {\n      this.maxAge = \"-Infinity\";\n    } else {\n      this.maxAge = age;\n    }\n  }\n  /**\n   * Encodes to a `Cookie` header value (specifically, the {@link Cookie.key} and {@link Cookie.value} properties joined with \"=\").\n   * @public\n   */\n  cookieString() {\n    const val = this.value || \"\";\n    if (this.key) {\n      return `${this.key}=${val}`;\n    }\n    return val;\n  }\n  /**\n   * Encodes to a `Set-Cookie header` value.\n   * @public\n   */\n  toString() {\n    let str = this.cookieString();\n    if (this.expires != \"Infinity\") {\n      if (this.expires instanceof Date) {\n        str += `; Expires=${formatDate(this.expires)}`;\n      }\n    }\n    if (this.maxAge != null && this.maxAge != Infinity) {\n      str += `; Max-Age=${String(this.maxAge)}`;\n    }\n    if (this.domain && !this.hostOnly) {\n      str += `; Domain=${this.domain}`;\n    }\n    if (this.path) {\n      str += `; Path=${this.path}`;\n    }\n    if (this.secure) {\n      str += \"; Secure\";\n    }\n    if (this.httpOnly) {\n      str += \"; HttpOnly\";\n    }\n    if (this.sameSite && this.sameSite !== \"none\") {\n      if (this.sameSite.toLowerCase() === _Cookie.sameSiteCanonical.lax.toLowerCase()) {\n        str += `; SameSite=${_Cookie.sameSiteCanonical.lax}`;\n      } else if (this.sameSite.toLowerCase() === _Cookie.sameSiteCanonical.strict.toLowerCase()) {\n        str += `; SameSite=${_Cookie.sameSiteCanonical.strict}`;\n      } else {\n        str += `; SameSite=${this.sameSite}`;\n      }\n    }\n    if (this.extensions) {\n      this.extensions.forEach((ext) => {\n        str += `; ${ext}`;\n      });\n    }\n    return str;\n  }\n  /**\n   * Computes the TTL relative to now (milliseconds).\n   *\n   * @remarks\n   * - `Infinity` is returned for cookies without an explicit expiry\n   *\n   * - `0` is returned if the cookie is expired.\n   *\n   * - Otherwise a time-to-live in milliseconds is returned.\n   *\n   * @param now - passing an explicit value is mostly used for testing purposes since this defaults to the `Date.now()`\n   * @public\n   */\n  TTL(now = Date.now()) {\n    if (this.maxAge != null && typeof this.maxAge === \"number\") {\n      return this.maxAge <= 0 ? 0 : this.maxAge * 1e3;\n    }\n    const expires = this.expires;\n    if (expires === \"Infinity\") {\n      return Infinity;\n    }\n    return (expires?.getTime() ?? now) - (now || Date.now());\n  }\n  /**\n   * Computes the absolute unix-epoch milliseconds that this cookie expires.\n   *\n   * The \"Max-Age\" attribute takes precedence over \"Expires\" (as per the RFC). The {@link Cookie.lastAccessed} attribute\n   * (or the `now` parameter if given) is used to offset the {@link Cookie.maxAge} attribute.\n   *\n   * If Expires ({@link Cookie.expires}) is set, that's returned.\n   *\n   * @param now - can be used to provide a time offset (instead of {@link Cookie.lastAccessed}) to use when calculating the \"Max-Age\" value\n   */\n  expiryTime(now) {\n    if (this.maxAge != null) {\n      const relativeTo = now || this.lastAccessed || /* @__PURE__ */ new Date();\n      const maxAge = typeof this.maxAge === \"number\" ? this.maxAge : -Infinity;\n      const age = maxAge <= 0 ? -Infinity : maxAge * 1e3;\n      if (relativeTo === \"Infinity\") {\n        return Infinity;\n      }\n      return relativeTo.getTime() + age;\n    }\n    if (this.expires == \"Infinity\") {\n      return Infinity;\n    }\n    return this.expires ? this.expires.getTime() : void 0;\n  }\n  /**\n   * Similar to {@link Cookie.expiryTime}, computes the absolute unix-epoch milliseconds that this cookie expires and returns it as a Date.\n   *\n   * The \"Max-Age\" attribute takes precedence over \"Expires\" (as per the RFC). The {@link Cookie.lastAccessed} attribute\n   * (or the `now` parameter if given) is used to offset the {@link Cookie.maxAge} attribute.\n   *\n   * If Expires ({@link Cookie.expires}) is set, that's returned.\n   *\n   * @param now - can be used to provide a time offset (instead of {@link Cookie.lastAccessed}) to use when calculating the \"Max-Age\" value\n   */\n  expiryDate(now) {\n    const millisec = this.expiryTime(now);\n    if (millisec == Infinity) {\n      return /* @__PURE__ */ new Date(2147483647e3);\n    } else if (millisec == -Infinity) {\n      return /* @__PURE__ */ new Date(0);\n    } else {\n      return millisec == void 0 ? void 0 : new Date(millisec);\n    }\n  }\n  /**\n   * Indicates if the cookie has been persisted to a store or not.\n   * @public\n   */\n  isPersistent() {\n    return this.maxAge != null || this.expires != \"Infinity\";\n  }\n  /**\n   * Calls {@link canonicalDomain} with the {@link Cookie.domain} property.\n   * @public\n   */\n  canonicalizedDomain() {\n    return canonicalDomain(this.domain);\n  }\n  /**\n   * Alias for {@link Cookie.canonicalizedDomain}\n   * @public\n   */\n  cdomain() {\n    return canonicalDomain(this.domain);\n  }\n  /**\n   * Parses a string into a Cookie object.\n   *\n   * @remarks\n   * Note: when parsing a `Cookie` header it must be split by ';' before each Cookie string can be parsed.\n   *\n   * @example\n   * ```\n   * // parse a `Set-Cookie` header\n   * const setCookieHeader = 'a=bcd; Expires=Tue, 18 Oct 2011 07:05:03 GMT'\n   * const cookie = Cookie.parse(setCookieHeader)\n   * cookie.key === 'a'\n   * cookie.value === 'bcd'\n   * cookie.expires === new Date(Date.parse('Tue, 18 Oct 2011 07:05:03 GMT'))\n   * ```\n   *\n   * @example\n   * ```\n   * // parse a `Cookie` header\n   * const cookieHeader = 'name=value; name2=value2; name3=value3'\n   * const cookies = cookieHeader.split(';').map(Cookie.parse)\n   * cookies[0].name === 'name'\n   * cookies[0].value === 'value'\n   * cookies[1].name === 'name2'\n   * cookies[1].value === 'value2'\n   * cookies[2].name === 'name3'\n   * cookies[2].value === 'value3'\n   * ```\n   *\n   * @param str - The `Set-Cookie` header or a Cookie string to parse.\n   * @param options - Configures `strict` or `loose` mode for cookie parsing\n   */\n  static parse(str, options) {\n    return parse(str, options);\n  }\n  /**\n   * Does the reverse of {@link Cookie.toJSON}.\n   *\n   * @remarks\n   * Any Date properties (such as .expires, .creation, and .lastAccessed) are parsed via Date.parse, not tough-cookie's parseDate, since ISO timestamps are being handled at this layer.\n   *\n   * @example\n   * ```\n   * const json = JSON.stringify({\n   *   key: 'alpha',\n   *   value: 'beta',\n   *   domain: 'example.com',\n   *   path: '/foo',\n   *   expires: '2038-01-19T03:14:07.000Z',\n   * })\n   * const cookie = Cookie.fromJSON(json)\n   * cookie.key === 'alpha'\n   * cookie.value === 'beta'\n   * cookie.domain === 'example.com'\n   * cookie.path === '/foo'\n   * cookie.expires === new Date(Date.parse('2038-01-19T03:14:07.000Z'))\n   * ```\n   *\n   * @param str - An unparsed JSON string or a value that has already been parsed as JSON\n   */\n  static fromJSON(str) {\n    return fromJSON(str);\n  }\n};\n_Cookie.cookiesCreated = 0;\n/**\n * @internal\n */\n_Cookie.sameSiteLevel = {\n  strict: 3,\n  lax: 2,\n  none: 1\n};\n/**\n * @internal\n */\n_Cookie.sameSiteCanonical = {\n  strict: \"Strict\",\n  lax: \"Lax\"\n};\n/**\n * Cookie properties that will be serialized when using {@link Cookie.fromJSON} and {@link Cookie.toJSON}.\n * @public\n */\n_Cookie.serializableProperties = [\n  \"key\",\n  \"value\",\n  \"expires\",\n  \"maxAge\",\n  \"domain\",\n  \"path\",\n  \"secure\",\n  \"httpOnly\",\n  \"extensions\",\n  \"hostOnly\",\n  \"pathIsDefault\",\n  \"creation\",\n  \"lastAccessed\",\n  \"sameSite\"\n];\nvar Cookie = _Cookie;\n\n// lib/cookie/cookieCompare.ts\nvar MAX_TIME = 2147483647e3;\nfunction cookieCompare(a, b) {\n  let cmp;\n  const aPathLen = a.path ? a.path.length : 0;\n  const bPathLen = b.path ? b.path.length : 0;\n  cmp = bPathLen - aPathLen;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  const aTime = a.creation && a.creation instanceof Date ? a.creation.getTime() : MAX_TIME;\n  const bTime = b.creation && b.creation instanceof Date ? b.creation.getTime() : MAX_TIME;\n  cmp = aTime - bTime;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = (a.creationIndex || 0) - (b.creationIndex || 0);\n  return cmp;\n}\n\n// lib/cookie/defaultPath.ts\nfunction defaultPath(path) {\n  if (!path || path.slice(0, 1) !== \"/\") {\n    return \"/\";\n  }\n  if (path === \"/\") {\n    return path;\n  }\n  const rightSlash = path.lastIndexOf(\"/\");\n  if (rightSlash === 0) {\n    return \"/\";\n  }\n  return path.slice(0, rightSlash);\n}\n\n// lib/cookie/domainMatch.ts\nvar IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$)|(?:^(?:(?:[a-f\\d]{1,4}:){7}(?:[a-f\\d]{1,4}|:)|(?:[a-f\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-f\\d]{1,4}|:)|(?:[a-f\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,2}|:)|(?:[a-f\\d]{1,4}:){4}(?:(?::[a-f\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,3}|:)|(?:[a-f\\d]{1,4}:){3}(?:(?::[a-f\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,4}|:)|(?:[a-f\\d]{1,4}:){2}(?:(?::[a-f\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,5}|:)|(?:[a-f\\d]{1,4}:){1}(?:(?::[a-f\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,7}|:)))$)/;\nfunction domainMatch(domain, cookieDomain, canonicalize) {\n  if (domain == null || cookieDomain == null) {\n    return void 0;\n  }\n  let _str;\n  let _domStr;\n  if (canonicalize !== false) {\n    _str = canonicalDomain(domain);\n    _domStr = canonicalDomain(cookieDomain);\n  } else {\n    _str = domain;\n    _domStr = cookieDomain;\n  }\n  if (_str == null || _domStr == null) {\n    return void 0;\n  }\n  if (_str == _domStr) {\n    return true;\n  }\n  const idx = _str.lastIndexOf(_domStr);\n  if (idx <= 0) {\n    return false;\n  }\n  if (_str.length !== _domStr.length + idx) {\n    return false;\n  }\n  if (_str.substring(idx - 1, idx) !== \".\") {\n    return false;\n  }\n  return !IP_REGEX_LOWERCASE.test(_str);\n}\n\n// lib/cookie/secureContext.ts\nfunction isLoopbackV4(address) {\n  const octets = address.split(\".\");\n  return octets.length === 4 && octets[0] !== void 0 && parseInt(octets[0], 10) === 127;\n}\nfunction isLoopbackV6(address) {\n  return address === \"::1\";\n}\nfunction isNormalizedLocalhostTLD(lowerHost) {\n  return lowerHost.endsWith(\".localhost\");\n}\nfunction isLocalHostname(host) {\n  const lowerHost = host.toLowerCase();\n  return lowerHost === \"localhost\" || isNormalizedLocalhostTLD(lowerHost);\n}\nfunction hostNoBrackets(host) {\n  if (host.length >= 2 && host.startsWith(\"[\") && host.endsWith(\"]\")) {\n    return host.substring(1, host.length - 1);\n  }\n  return host;\n}\nfunction isPotentiallyTrustworthy(inputUrl, allowSecureOnLocal = true) {\n  let url;\n  if (typeof inputUrl === \"string\") {\n    try {\n      url = new URL(inputUrl);\n    } catch {\n      return false;\n    }\n  } else {\n    url = inputUrl;\n  }\n  const scheme = url.protocol.replace(\":\", \"\").toLowerCase();\n  const hostname = hostNoBrackets(url.hostname).replace(/\\.+$/, \"\");\n  if (scheme === \"https\" || scheme === \"wss\") {\n    return true;\n  }\n  if (!allowSecureOnLocal) {\n    return false;\n  }\n  if (IP_V4_REGEX_OBJECT.test(hostname)) {\n    return isLoopbackV4(hostname);\n  }\n  if (IP_V6_REGEX_OBJECT.test(hostname)) {\n    return isLoopbackV6(hostname);\n  }\n  return isLocalHostname(hostname);\n}\n\n// lib/cookie/cookieJar.ts\nvar defaultSetCookieOptions = {\n  loose: false,\n  sameSiteContext: void 0,\n  ignoreError: false,\n  http: true\n};\nvar defaultGetCookieOptions = {\n  http: true,\n  expire: true,\n  allPaths: false,\n  sameSiteContext: void 0,\n  sort: void 0\n};\nvar SAME_SITE_CONTEXT_VAL_ERR = 'Invalid sameSiteContext option for getCookies(); expected one of \"strict\", \"lax\", or \"none\"';\nfunction getCookieContext(url) {\n  if (url && typeof url === \"object\" && \"hostname\" in url && typeof url.hostname === \"string\" && \"pathname\" in url && typeof url.pathname === \"string\" && \"protocol\" in url && typeof url.protocol === \"string\") {\n    return {\n      hostname: url.hostname,\n      pathname: url.pathname,\n      protocol: url.protocol\n    };\n  } else if (typeof url === \"string\") {\n    try {\n      return new URL(decodeURI(url));\n    } catch {\n      return new URL(url);\n    }\n  } else {\n    throw new ParameterError(\"`url` argument is not a string or URL.\");\n  }\n}\nfunction checkSameSiteContext(value) {\n  const context = String(value).toLowerCase();\n  if (context === \"none\" || context === \"lax\" || context === \"strict\") {\n    return context;\n  } else {\n    return void 0;\n  }\n}\nfunction isSecurePrefixConditionMet(cookie) {\n  const startsWithSecurePrefix = typeof cookie.key === \"string\" && cookie.key.startsWith(\"__Secure-\");\n  return !startsWithSecurePrefix || cookie.secure;\n}\nfunction isHostPrefixConditionMet(cookie) {\n  const startsWithHostPrefix = typeof cookie.key === \"string\" && cookie.key.startsWith(\"__Host-\");\n  return !startsWithHostPrefix || Boolean(\n    cookie.secure && cookie.hostOnly && cookie.path != null && cookie.path === \"/\"\n  );\n}\nfunction getNormalizedPrefixSecurity(prefixSecurity) {\n  const normalizedPrefixSecurity = prefixSecurity.toLowerCase();\n  switch (normalizedPrefixSecurity) {\n    case PrefixSecurityEnum.STRICT:\n    case PrefixSecurityEnum.SILENT:\n    case PrefixSecurityEnum.DISABLED:\n      return normalizedPrefixSecurity;\n    default:\n      return PrefixSecurityEnum.SILENT;\n  }\n}\nvar CookieJar = class _CookieJar {\n  /**\n   * Creates a new `CookieJar` instance.\n   *\n   * @remarks\n   * - If a custom store is not passed to the constructor, an in-memory store ({@link MemoryCookieStore} will be created and used.\n   * - If a boolean value is passed as the `options` parameter, this is equivalent to passing `{ rejectPublicSuffixes: <value> }`\n   *\n   * @param store - a custom {@link Store} implementation (defaults to {@link MemoryCookieStore})\n   * @param options - configures how cookies are processed by the cookie jar\n   */\n  constructor(store, options) {\n    if (typeof options === \"boolean\") {\n      options = { rejectPublicSuffixes: options };\n    }\n    this.rejectPublicSuffixes = options?.rejectPublicSuffixes ?? true;\n    this.enableLooseMode = options?.looseMode ?? false;\n    this.allowSpecialUseDomain = options?.allowSpecialUseDomain ?? true;\n    this.allowSecureOnLocal = options?.allowSecureOnLocal ?? true;\n    this.prefixSecurity = getNormalizedPrefixSecurity(\n      options?.prefixSecurity ?? \"silent\"\n    );\n    this.store = store ?? new MemoryCookieStore();\n  }\n  callSync(fn) {\n    if (!this.store.synchronous) {\n      throw new Error(\n        \"CookieJar store is not synchronous; use async API instead.\"\n      );\n    }\n    let syncErr = null;\n    let syncResult = void 0;\n    try {\n      fn.call(this, (error, result) => {\n        syncErr = error;\n        syncResult = result;\n      });\n    } catch (err) {\n      syncErr = err;\n    }\n    if (syncErr) throw syncErr;\n    return syncResult;\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  setCookie(cookie, url, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = void 0;\n    }\n    const promiseCallback = createPromiseCallback(callback);\n    const cb = promiseCallback.callback;\n    let context;\n    try {\n      if (typeof url === \"string\") {\n        validate(\n          isNonEmptyString(url),\n          callback,\n          safeToString(options)\n        );\n      }\n      context = getCookieContext(url);\n      if (typeof url === \"function\") {\n        return promiseCallback.reject(new Error(\"No URL was specified\"));\n      }\n      if (typeof options === \"function\") {\n        options = defaultSetCookieOptions;\n      }\n      validate(typeof cb === \"function\", cb);\n      if (!isNonEmptyString(cookie) && !isObject(cookie) && cookie instanceof String && cookie.length == 0) {\n        return promiseCallback.resolve(void 0);\n      }\n    } catch (err) {\n      return promiseCallback.reject(err);\n    }\n    const host = canonicalDomain(context.hostname) ?? null;\n    const loose = options?.loose || this.enableLooseMode;\n    let sameSiteContext = null;\n    if (options?.sameSiteContext) {\n      sameSiteContext = checkSameSiteContext(options.sameSiteContext);\n      if (!sameSiteContext) {\n        return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));\n      }\n    }\n    if (typeof cookie === \"string\" || cookie instanceof String) {\n      const parsedCookie = Cookie.parse(cookie.toString(), { loose });\n      if (!parsedCookie) {\n        const err = new Error(\"Cookie failed to parse\");\n        return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);\n      }\n      cookie = parsedCookie;\n    } else if (!(cookie instanceof Cookie)) {\n      const err = new Error(\n        \"First argument to setCookie must be a Cookie object or string\"\n      );\n      return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);\n    }\n    const now = options?.now || /* @__PURE__ */ new Date();\n    if (this.rejectPublicSuffixes && cookie.domain) {\n      try {\n        const cdomain = cookie.cdomain();\n        const suffix = typeof cdomain === \"string\" ? getPublicSuffix(cdomain, {\n          allowSpecialUseDomain: this.allowSpecialUseDomain,\n          ignoreError: options?.ignoreError\n        }) : null;\n        if (suffix == null && !IP_V6_REGEX_OBJECT.test(cookie.domain)) {\n          const err = new Error(\"Cookie has domain set to a public suffix\");\n          return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);\n        }\n      } catch (err) {\n        return options?.ignoreError ? promiseCallback.resolve(void 0) : (\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n          promiseCallback.reject(err)\n        );\n      }\n    }\n    if (cookie.domain) {\n      if (!domainMatch(host ?? void 0, cookie.cdomain() ?? void 0, false)) {\n        const err = new Error(\n          `Cookie not in this host's domain. Cookie:${cookie.cdomain() ?? \"null\"} Request:${host ?? \"null\"}`\n        );\n        return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);\n      }\n      if (cookie.hostOnly == null) {\n        cookie.hostOnly = false;\n      }\n    } else {\n      cookie.hostOnly = true;\n      cookie.domain = host;\n    }\n    if (!cookie.path || cookie.path[0] !== \"/\") {\n      cookie.path = defaultPath(context.pathname);\n      cookie.pathIsDefault = true;\n    }\n    if (options?.http === false && cookie.httpOnly) {\n      const err = new Error(\"Cookie is HttpOnly and this isn't an HTTP API\");\n      return options.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);\n    }\n    if (cookie.sameSite !== \"none\" && cookie.sameSite !== void 0 && sameSiteContext) {\n      if (sameSiteContext === \"none\") {\n        const err = new Error(\n          \"Cookie is SameSite but this is a cross-origin request\"\n        );\n        return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);\n      }\n    }\n    const ignoreErrorForPrefixSecurity = this.prefixSecurity === PrefixSecurityEnum.SILENT;\n    const prefixSecurityDisabled = this.prefixSecurity === PrefixSecurityEnum.DISABLED;\n    if (!prefixSecurityDisabled) {\n      let errorFound = false;\n      let errorMsg;\n      if (!isSecurePrefixConditionMet(cookie)) {\n        errorFound = true;\n        errorMsg = \"Cookie has __Secure prefix but Secure attribute is not set\";\n      } else if (!isHostPrefixConditionMet(cookie)) {\n        errorFound = true;\n        errorMsg = \"Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'\";\n      }\n      if (errorFound) {\n        return options?.ignoreError || ignoreErrorForPrefixSecurity ? promiseCallback.resolve(void 0) : promiseCallback.reject(new Error(errorMsg));\n      }\n    }\n    const store = this.store;\n    if (!store.updateCookie) {\n      store.updateCookie = async function(_oldCookie, newCookie, cb2) {\n        return this.putCookie(newCookie).then(\n          () => cb2?.(null),\n          (error) => cb2?.(error)\n        );\n      };\n    }\n    const withCookie = function withCookie2(err, oldCookie) {\n      if (err) {\n        cb(err);\n        return;\n      }\n      const next = function(err2) {\n        if (err2) {\n          cb(err2);\n        } else if (typeof cookie === \"string\") {\n          cb(null, void 0);\n        } else {\n          cb(null, cookie);\n        }\n      };\n      if (oldCookie) {\n        if (options && \"http\" in options && options.http === false && oldCookie.httpOnly) {\n          err = new Error(\"old Cookie is HttpOnly and this isn't an HTTP API\");\n          if (options.ignoreError) cb(null, void 0);\n          else cb(err);\n          return;\n        }\n        if (cookie instanceof Cookie) {\n          cookie.creation = oldCookie.creation;\n          cookie.creationIndex = oldCookie.creationIndex;\n          cookie.lastAccessed = now;\n          store.updateCookie(oldCookie, cookie, next);\n        }\n      } else {\n        if (cookie instanceof Cookie) {\n          cookie.creation = cookie.lastAccessed = now;\n          store.putCookie(cookie, next);\n        }\n      }\n    };\n    store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);\n    return promiseCallback.promise;\n  }\n  /**\n   * Synchronously attempt to set the {@link Cookie} in the {@link CookieJar}.\n   *\n   * <strong>Note:</strong> Only works if the configured {@link Store} is also synchronous.\n   *\n   * @remarks\n   * - If successfully persisted, the {@link Cookie} will have updated\n   *     {@link Cookie.creation}, {@link Cookie.lastAccessed} and {@link Cookie.hostOnly}\n   *     properties.\n   *\n   * - As per the RFC, the {@link Cookie.hostOnly} flag is set if there was no `Domain={value}`\n   *     attribute on the cookie string. The {@link Cookie.domain} property is set to the\n   *     fully-qualified hostname of `currentUrl` in this case. Matching this cookie requires an\n   *     exact hostname match (not a {@link domainMatch} as per usual)\n   *\n   * @param cookie - The cookie object or cookie string to store. A string value will be parsed into a cookie using {@link Cookie.parse}.\n   * @param url - The domain to store the cookie with.\n   * @param options - Configuration settings to use when storing the cookie.\n   * @public\n   */\n  setCookieSync(cookie, url, options) {\n    const setCookieFn = options ? this.setCookie.bind(this, cookie, url, options) : this.setCookie.bind(this, cookie, url);\n    return this.callSync(setCookieFn);\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  getCookies(url, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = defaultGetCookieOptions;\n    } else if (options === void 0) {\n      options = defaultGetCookieOptions;\n    }\n    const promiseCallback = createPromiseCallback(callback);\n    const cb = promiseCallback.callback;\n    let context;\n    try {\n      if (typeof url === \"string\") {\n        validate(isNonEmptyString(url), cb, url);\n      }\n      context = getCookieContext(url);\n      validate(\n        isObject(options),\n        cb,\n        safeToString(options)\n      );\n      validate(typeof cb === \"function\", cb);\n    } catch (parameterError) {\n      return promiseCallback.reject(parameterError);\n    }\n    const host = canonicalDomain(context.hostname);\n    const path = context.pathname || \"/\";\n    const potentiallyTrustworthy = isPotentiallyTrustworthy(\n      url,\n      this.allowSecureOnLocal\n    );\n    let sameSiteLevel = 0;\n    if (options.sameSiteContext) {\n      const sameSiteContext = checkSameSiteContext(options.sameSiteContext);\n      if (sameSiteContext == null) {\n        return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));\n      }\n      sameSiteLevel = Cookie.sameSiteLevel[sameSiteContext];\n      if (!sameSiteLevel) {\n        return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));\n      }\n    }\n    const http = options.http ?? true;\n    const now = Date.now();\n    const expireCheck = options.expire ?? true;\n    const allPaths = options.allPaths ?? false;\n    const store = this.store;\n    function matchingCookie(c) {\n      if (c.hostOnly) {\n        if (c.domain != host) {\n          return false;\n        }\n      } else {\n        if (!domainMatch(host ?? void 0, c.domain ?? void 0, false)) {\n          return false;\n        }\n      }\n      if (!allPaths && typeof c.path === \"string\" && !pathMatch(path, c.path)) {\n        return false;\n      }\n      if (c.secure && !potentiallyTrustworthy) {\n        return false;\n      }\n      if (c.httpOnly && !http) {\n        return false;\n      }\n      if (sameSiteLevel) {\n        let cookieLevel;\n        if (c.sameSite === \"lax\") {\n          cookieLevel = Cookie.sameSiteLevel.lax;\n        } else if (c.sameSite === \"strict\") {\n          cookieLevel = Cookie.sameSiteLevel.strict;\n        } else {\n          cookieLevel = Cookie.sameSiteLevel.none;\n        }\n        if (cookieLevel > sameSiteLevel) {\n          return false;\n        }\n      }\n      const expiryTime = c.expiryTime();\n      if (expireCheck && expiryTime != void 0 && expiryTime <= now) {\n        store.removeCookie(c.domain, c.path, c.key, () => {\n        });\n        return false;\n      }\n      return true;\n    }\n    store.findCookies(\n      host,\n      allPaths ? null : path,\n      this.allowSpecialUseDomain,\n      (err, cookies) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n        if (cookies == null) {\n          cb(null, []);\n          return;\n        }\n        cookies = cookies.filter(matchingCookie);\n        if (\"sort\" in options && options.sort !== false) {\n          cookies = cookies.sort(cookieCompare);\n        }\n        const now2 = /* @__PURE__ */ new Date();\n        for (const cookie of cookies) {\n          cookie.lastAccessed = now2;\n        }\n        cb(null, cookies);\n      }\n    );\n    return promiseCallback.promise;\n  }\n  /**\n   * Synchronously retrieve the list of cookies that can be sent in a Cookie header for the\n   * current URL.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   *\n   * @remarks\n   * - The array of cookies returned will be sorted according to {@link cookieCompare}.\n   *\n   * - The {@link Cookie.lastAccessed} property will be updated on all returned cookies.\n   *\n   * @param url - The domain to store the cookie with.\n   * @param options - Configuration settings to use when retrieving the cookies.\n   */\n  getCookiesSync(url, options) {\n    return this.callSync(this.getCookies.bind(this, url, options)) ?? [];\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  getCookieString(url, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = void 0;\n    }\n    const promiseCallback = createPromiseCallback(callback);\n    const next = function(err, cookies) {\n      if (err) {\n        promiseCallback.callback(err);\n      } else {\n        promiseCallback.callback(\n          null,\n          cookies?.sort(cookieCompare).map((c) => c.cookieString()).join(\"; \")\n        );\n      }\n    };\n    this.getCookies(url, options, next);\n    return promiseCallback.promise;\n  }\n  /**\n   * Synchronous version of `.getCookieString()`. Accepts the same options as `.getCookies()` but returns a string suitable for a\n   * `Cookie` header rather than an Array.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   *\n   * @param url - The domain to store the cookie with.\n   * @param options - Configuration settings to use when retrieving the cookies.\n   */\n  getCookieStringSync(url, options) {\n    return this.callSync(\n      options ? this.getCookieString.bind(this, url, options) : this.getCookieString.bind(this, url)\n    ) ?? \"\";\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  getSetCookieStrings(url, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = void 0;\n    }\n    const promiseCallback = createPromiseCallback(\n      callback\n    );\n    const next = function(err, cookies) {\n      if (err) {\n        promiseCallback.callback(err);\n      } else {\n        promiseCallback.callback(\n          null,\n          cookies?.map((c) => {\n            return c.toString();\n          })\n        );\n      }\n    };\n    this.getCookies(url, options, next);\n    return promiseCallback.promise;\n  }\n  /**\n   * Synchronous version of `.getSetCookieStrings()`. Returns an array of strings suitable for `Set-Cookie` headers.\n   * Accepts the same options as `.getCookies()`.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   *\n   * @param url - The domain to store the cookie with.\n   * @param options - Configuration settings to use when retrieving the cookies.\n   */\n  getSetCookieStringsSync(url, options = {}) {\n    return this.callSync(this.getSetCookieStrings.bind(this, url, options)) ?? [];\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  serialize(callback) {\n    const promiseCallback = createPromiseCallback(callback);\n    let type = this.store.constructor.name;\n    if (isObject(type)) {\n      type = null;\n    }\n    const serialized = {\n      // The version of tough-cookie that serialized this jar. Generally a good\n      // practice since future versions can make data import decisions based on\n      // known past behavior. When/if this matters, use `semver`.\n      version: `tough-cookie@${version}`,\n      // add the store type, to make humans happy:\n      storeType: type,\n      // CookieJar configuration:\n      rejectPublicSuffixes: this.rejectPublicSuffixes,\n      enableLooseMode: this.enableLooseMode,\n      allowSpecialUseDomain: this.allowSpecialUseDomain,\n      prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),\n      // this gets filled from getAllCookies:\n      cookies: []\n    };\n    if (typeof this.store.getAllCookies !== \"function\") {\n      return promiseCallback.reject(\n        new Error(\n          \"store does not support getAllCookies and cannot be serialized\"\n        )\n      );\n    }\n    this.store.getAllCookies((err, cookies) => {\n      if (err) {\n        promiseCallback.callback(err);\n        return;\n      }\n      if (cookies == null) {\n        promiseCallback.callback(null, serialized);\n        return;\n      }\n      serialized.cookies = cookies.map((cookie) => {\n        const serializedCookie = cookie.toJSON();\n        delete serializedCookie.creationIndex;\n        return serializedCookie;\n      });\n      promiseCallback.callback(null, serialized);\n    });\n    return promiseCallback.promise;\n  }\n  /**\n   * Serialize the CookieJar if the underlying store supports `.getAllCookies`.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   */\n  serializeSync() {\n    return this.callSync((callback) => {\n      this.serialize(callback);\n    });\n  }\n  /**\n   * Alias of {@link CookieJar.serializeSync}. Allows the cookie to be serialized\n   * with `JSON.stringify(cookieJar)`.\n   */\n  toJSON() {\n    return this.serializeSync();\n  }\n  /**\n   * Use the class method CookieJar.deserialize instead of calling this directly\n   * @internal\n   */\n  _importCookies(serialized, callback) {\n    let cookies = void 0;\n    if (serialized && typeof serialized === \"object\" && inOperator(\"cookies\", serialized) && Array.isArray(serialized.cookies)) {\n      cookies = serialized.cookies;\n    }\n    if (!cookies) {\n      callback(new Error(\"serialized jar has no cookies array\"), void 0);\n      return;\n    }\n    cookies = cookies.slice();\n    const putNext = (err) => {\n      if (err) {\n        callback(err, void 0);\n        return;\n      }\n      if (Array.isArray(cookies)) {\n        if (!cookies.length) {\n          callback(err, this);\n          return;\n        }\n        let cookie;\n        try {\n          cookie = Cookie.fromJSON(cookies.shift());\n        } catch (e) {\n          callback(e instanceof Error ? e : new Error(), void 0);\n          return;\n        }\n        if (cookie === void 0) {\n          putNext(null);\n          return;\n        }\n        this.store.putCookie(cookie, putNext);\n      }\n    };\n    putNext(null);\n  }\n  /**\n   * @internal\n   */\n  _importCookiesSync(serialized) {\n    this.callSync(this._importCookies.bind(this, serialized));\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  clone(newStore, callback) {\n    if (typeof newStore === \"function\") {\n      callback = newStore;\n      newStore = void 0;\n    }\n    const promiseCallback = createPromiseCallback(callback);\n    const cb = promiseCallback.callback;\n    this.serialize((err, serialized) => {\n      if (err) {\n        return promiseCallback.reject(err);\n      }\n      return _CookieJar.deserialize(serialized ?? \"\", newStore, cb);\n    });\n    return promiseCallback.promise;\n  }\n  /**\n   * @internal\n   */\n  _cloneSync(newStore) {\n    const cloneFn = newStore && typeof newStore !== \"function\" ? this.clone.bind(this, newStore) : this.clone.bind(this);\n    return this.callSync((callback) => {\n      cloneFn(callback);\n    });\n  }\n  /**\n   * Produces a deep clone of this CookieJar. Modifications to the original do\n   * not affect the clone, and vice versa.\n   *\n   * <strong>Note</strong>: Only works if both the configured Store and destination\n   * Store are synchronous.\n   *\n   * @remarks\n   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.\n   *\n   * - Transferring between store types is supported so long as the source\n   *     implements `.getAllCookies()` and the destination implements `.putCookie()`.\n   *\n   * @param newStore - The target {@link Store} to clone cookies into.\n   */\n  cloneSync(newStore) {\n    if (!newStore) {\n      return this._cloneSync();\n    }\n    if (!newStore.synchronous) {\n      throw new Error(\n        \"CookieJar clone destination store is not synchronous; use async API instead.\"\n      );\n    }\n    return this._cloneSync(newStore);\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  removeAllCookies(callback) {\n    const promiseCallback = createPromiseCallback(callback);\n    const cb = promiseCallback.callback;\n    const store = this.store;\n    if (typeof store.removeAllCookies === \"function\" && store.removeAllCookies !== Store.prototype.removeAllCookies) {\n      store.removeAllCookies(cb);\n      return promiseCallback.promise;\n    }\n    store.getAllCookies((err, cookies) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n      if (!cookies) {\n        cookies = [];\n      }\n      if (cookies.length === 0) {\n        cb(null, void 0);\n        return;\n      }\n      let completedCount = 0;\n      const removeErrors = [];\n      const removeCookieCb = function removeCookieCb2(removeErr) {\n        if (removeErr) {\n          removeErrors.push(removeErr);\n        }\n        completedCount++;\n        if (completedCount === cookies.length) {\n          if (removeErrors[0]) cb(removeErrors[0]);\n          else cb(null, void 0);\n          return;\n        }\n      };\n      cookies.forEach((cookie) => {\n        store.removeCookie(\n          cookie.domain,\n          cookie.path,\n          cookie.key,\n          removeCookieCb\n        );\n      });\n    });\n    return promiseCallback.promise;\n  }\n  /**\n   * Removes all cookies from the CookieJar.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   *\n   * @remarks\n   * - This is a new backwards-compatible feature of tough-cookie version 2.5,\n   *     so not all Stores will implement it efficiently. For Stores that do not\n   *     implement `removeAllCookies`, the fallback is to call `removeCookie` after\n   *     `getAllCookies`.\n   *\n   * - If `getAllCookies` fails or isn't implemented in the Store, an error is returned.\n   *\n   * - If one or more of the `removeCookie` calls fail, only the first error is returned.\n   */\n  removeAllCookiesSync() {\n    this.callSync((callback) => {\n      this.removeAllCookies(callback);\n    });\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  static deserialize(strOrObj, store, callback) {\n    if (typeof store === \"function\") {\n      callback = store;\n      store = void 0;\n    }\n    const promiseCallback = createPromiseCallback(callback);\n    let serialized;\n    if (typeof strOrObj === \"string\") {\n      try {\n        serialized = JSON.parse(strOrObj);\n      } catch (e) {\n        return promiseCallback.reject(e instanceof Error ? e : new Error());\n      }\n    } else {\n      serialized = strOrObj;\n    }\n    const readSerializedProperty = (property) => {\n      return serialized && typeof serialized === \"object\" && inOperator(property, serialized) ? serialized[property] : void 0;\n    };\n    const readSerializedBoolean = (property) => {\n      const value = readSerializedProperty(property);\n      return typeof value === \"boolean\" ? value : void 0;\n    };\n    const readSerializedString = (property) => {\n      const value = readSerializedProperty(property);\n      return typeof value === \"string\" ? value : void 0;\n    };\n    const jar = new _CookieJar(store, {\n      rejectPublicSuffixes: readSerializedBoolean(\"rejectPublicSuffixes\"),\n      looseMode: readSerializedBoolean(\"enableLooseMode\"),\n      allowSpecialUseDomain: readSerializedBoolean(\"allowSpecialUseDomain\"),\n      prefixSecurity: getNormalizedPrefixSecurity(\n        readSerializedString(\"prefixSecurity\") ?? \"silent\"\n      )\n    });\n    jar._importCookies(serialized, (err) => {\n      if (err) {\n        promiseCallback.callback(err);\n        return;\n      }\n      promiseCallback.callback(null, jar);\n    });\n    return promiseCallback.promise;\n  }\n  /**\n   * A new CookieJar is created and the serialized {@link Cookie} values are added to\n   * the underlying store. Each {@link Cookie} is added via `store.putCookie(...)` in\n   * the order in which they appear in the serialization.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   *\n   * @remarks\n   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.\n   *\n   * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.\n   *\n   * @param strOrObj - A JSON string or object representing the deserialized cookies.\n   * @param store - The underlying store to persist the deserialized cookies into.\n   */\n  static deserializeSync(strOrObj, store) {\n    const serialized = typeof strOrObj === \"string\" ? JSON.parse(strOrObj) : strOrObj;\n    const readSerializedProperty = (property) => {\n      return serialized && typeof serialized === \"object\" && inOperator(property, serialized) ? serialized[property] : void 0;\n    };\n    const readSerializedBoolean = (property) => {\n      const value = readSerializedProperty(property);\n      return typeof value === \"boolean\" ? value : void 0;\n    };\n    const readSerializedString = (property) => {\n      const value = readSerializedProperty(property);\n      return typeof value === \"string\" ? value : void 0;\n    };\n    const jar = new _CookieJar(store, {\n      rejectPublicSuffixes: readSerializedBoolean(\"rejectPublicSuffixes\"),\n      looseMode: readSerializedBoolean(\"enableLooseMode\"),\n      allowSpecialUseDomain: readSerializedBoolean(\"allowSpecialUseDomain\"),\n      prefixSecurity: getNormalizedPrefixSecurity(\n        readSerializedString(\"prefixSecurity\") ?? \"silent\"\n      )\n    });\n    if (!jar.store.synchronous) {\n      throw new Error(\n        \"CookieJar store is not synchronous; use async API instead.\"\n      );\n    }\n    jar._importCookiesSync(serialized);\n    return jar;\n  }\n  /**\n   * Alias of {@link CookieJar.deserializeSync}.\n   *\n   * @remarks\n   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.\n   *\n   * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.\n   *\n   * @param jsonString - A JSON string or object representing the deserialized cookies.\n   * @param store - The underlying store to persist the deserialized cookies into.\n   */\n  static fromJSON(jsonString, store) {\n    return _CookieJar.deserializeSync(jsonString, store);\n  }\n};\n\n// lib/cookie/permutePath.ts\nfunction permutePath(path) {\n  if (path === \"/\") {\n    return [\"/\"];\n  }\n  const permutations = [path];\n  while (path.length > 1) {\n    const lindex = path.lastIndexOf(\"/\");\n    if (lindex === 0) {\n      break;\n    }\n    path = path.slice(0, lindex);\n    permutations.push(path);\n  }\n  permutations.push(\"/\");\n  return permutations;\n}\n\n// lib/cookie/index.ts\nfunction parse2(str, options) {\n  return Cookie.parse(str, options);\n}\nfunction fromJSON2(str) {\n  return Cookie.fromJSON(str);\n}\n\n/*!\n * Copyright (c) 2015-2020, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQixHQUFHLGVBQWU7QUFDcEQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZUFBZSwrRUFBK0UseURBQXlEO0FBQzVNO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQVM7QUFDaEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSyxHQUFHLElBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QWUsSUFBSSxHQUFHLEVBQUUsZUFBZSxJQUFJLEVBQUUsSUFBSSxrRkFBa0YsRUFBRSxhQUFhLElBQUksRUFBRSxJQUFJLGVBQWUsSUFBSSxHQUFHLEVBQUUsZUFBZSxJQUFJLEVBQUUsSUFBSSxrRkFBa0YsRUFBRSxhQUFhLElBQUksRUFBRSxJQUFJLGVBQWUsSUFBSSxHQUFHLEVBQUUsZUFBZSxJQUFJLEVBQUUsSUFBSSxrRkFBa0YsRUFBRSxhQUFhLElBQUksRUFBRSxJQUFJLGVBQWUsSUFBSSxHQUFHLEVBQUUsZUFBZSxJQUFJLEVBQUUsSUFBSSxrRkFBa0YsRUFBRSxhQUFhLElBQUksRUFBRSxJQUFJLHVCQUF1QixJQUFJLEVBQUUsSUFBSSxrRkFBa0YsRUFBRSxhQUFhLElBQUksRUFBRSxJQUFJO0FBQzVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFB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LE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG9CQUFvQjtBQUN0RjtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLG9CQUFvQix5QkFBeUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYztBQUNsRSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWEsb0JBQW9CLHlCQUF5QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBLGdCQUFnQixhQUFhLG9CQUFvQix5QkFBeUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXFCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQkFBK0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3ViZXJ0Ly4vbm9kZV9tb2R1bGVzL3RvdWdoLWNvb2tpZS9kaXN0L2luZGV4LmpzPzNjZjkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGliL3BhdGhNYXRjaC50c1xuZnVuY3Rpb24gcGF0aE1hdGNoKHJlcVBhdGgsIGNvb2tpZVBhdGgpIHtcbiAgaWYgKGNvb2tpZVBhdGggPT09IHJlcVBhdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBpZHggPSByZXFQYXRoLmluZGV4T2YoY29va2llUGF0aCk7XG4gIGlmIChpZHggPT09IDApIHtcbiAgICBpZiAoY29va2llUGF0aFtjb29raWVQYXRoLmxlbmd0aCAtIDFdID09PSBcIi9cIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyZXFQYXRoLnN0YXJ0c1dpdGgoY29va2llUGF0aCkgJiYgcmVxUGF0aFtjb29raWVQYXRoLmxlbmd0aF0gPT09IFwiL1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBsaWIvZ2V0UHVibGljU3VmZml4LnRzXG5pbXBvcnQgeyBnZXREb21haW4gfSBmcm9tIFwidGxkdHNcIjtcbnZhciBTUEVDSUFMX1VTRV9ET01BSU5TID0gW1wibG9jYWxcIiwgXCJleGFtcGxlXCIsIFwiaW52YWxpZFwiLCBcImxvY2FsaG9zdFwiLCBcInRlc3RcIl07XG52YXIgU1BFQ0lBTF9UUkVBVE1FTlRfRE9NQUlOUyA9IFtcImxvY2FsaG9zdFwiLCBcImludmFsaWRcIl07XG52YXIgZGVmYXVsdEdldFB1YmxpY1N1ZmZpeE9wdGlvbnMgPSB7XG4gIGFsbG93U3BlY2lhbFVzZURvbWFpbjogZmFsc2UsXG4gIGlnbm9yZUVycm9yOiBmYWxzZVxufTtcbmZ1bmN0aW9uIGdldFB1YmxpY1N1ZmZpeChkb21haW4sIG9wdGlvbnMgPSB7fSkge1xuICBvcHRpb25zID0geyAuLi5kZWZhdWx0R2V0UHVibGljU3VmZml4T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICBjb25zdCBkb21haW5QYXJ0cyA9IGRvbWFpbi5zcGxpdChcIi5cIik7XG4gIGNvbnN0IHRvcExldmVsRG9tYWluID0gZG9tYWluUGFydHNbZG9tYWluUGFydHMubGVuZ3RoIC0gMV07XG4gIGNvbnN0IGFsbG93U3BlY2lhbFVzZURvbWFpbiA9ICEhb3B0aW9ucy5hbGxvd1NwZWNpYWxVc2VEb21haW47XG4gIGNvbnN0IGlnbm9yZUVycm9yID0gISFvcHRpb25zLmlnbm9yZUVycm9yO1xuICBpZiAoYWxsb3dTcGVjaWFsVXNlRG9tYWluICYmIHRvcExldmVsRG9tYWluICE9PSB2b2lkIDAgJiYgU1BFQ0lBTF9VU0VfRE9NQUlOUy5pbmNsdWRlcyh0b3BMZXZlbERvbWFpbikpIHtcbiAgICBpZiAoZG9tYWluUGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3Qgc2Vjb25kTGV2ZWxEb21haW4gPSBkb21haW5QYXJ0c1tkb21haW5QYXJ0cy5sZW5ndGggLSAyXTtcbiAgICAgIHJldHVybiBgJHtzZWNvbmRMZXZlbERvbWFpbn0uJHt0b3BMZXZlbERvbWFpbn1gO1xuICAgIH0gZWxzZSBpZiAoU1BFQ0lBTF9UUkVBVE1FTlRfRE9NQUlOUy5pbmNsdWRlcyh0b3BMZXZlbERvbWFpbikpIHtcbiAgICAgIHJldHVybiB0b3BMZXZlbERvbWFpbjtcbiAgICB9XG4gIH1cbiAgaWYgKCFpZ25vcmVFcnJvciAmJiB0b3BMZXZlbERvbWFpbiAhPT0gdm9pZCAwICYmIFNQRUNJQUxfVVNFX0RPTUFJTlMuaW5jbHVkZXModG9wTGV2ZWxEb21haW4pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENvb2tpZSBoYXMgZG9tYWluIHNldCB0byB0aGUgcHVibGljIHN1ZmZpeCBcIiR7dG9wTGV2ZWxEb21haW59XCIgd2hpY2ggaXMgYSBzcGVjaWFsIHVzZSBkb21haW4uIFRvIGFsbG93IHRoaXMsIGNvbmZpZ3VyZSB5b3VyIENvb2tpZUphciB3aXRoIHthbGxvd1NwZWNpYWxVc2VEb21haW46IHRydWUsIHJlamVjdFB1YmxpY1N1ZmZpeGVzOiBmYWxzZX0uYFxuICAgICk7XG4gIH1cbiAgY29uc3QgcHVibGljU3VmZml4ID0gZ2V0RG9tYWluKGRvbWFpbiwge1xuICAgIGFsbG93SWNhbm5Eb21haW5zOiB0cnVlLFxuICAgIGFsbG93UHJpdmF0ZURvbWFpbnM6IHRydWVcbiAgfSk7XG4gIGlmIChwdWJsaWNTdWZmaXgpIHJldHVybiBwdWJsaWNTdWZmaXg7XG59XG5cbi8vIGxpYi9wZXJtdXRlRG9tYWluLnRzXG5mdW5jdGlvbiBwZXJtdXRlRG9tYWluKGRvbWFpbiwgYWxsb3dTcGVjaWFsVXNlRG9tYWluKSB7XG4gIGNvbnN0IHB1YlN1ZiA9IGdldFB1YmxpY1N1ZmZpeChkb21haW4sIHtcbiAgICBhbGxvd1NwZWNpYWxVc2VEb21haW5cbiAgfSk7XG4gIGlmICghcHViU3VmKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAocHViU3VmID09IGRvbWFpbikge1xuICAgIHJldHVybiBbZG9tYWluXTtcbiAgfVxuICBpZiAoZG9tYWluLnNsaWNlKC0xKSA9PSBcIi5cIikge1xuICAgIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgwLCAtMSk7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gZG9tYWluLnNsaWNlKDAsIC0ocHViU3VmLmxlbmd0aCArIDEpKTtcbiAgY29uc3QgcGFydHMgPSBwcmVmaXguc3BsaXQoXCIuXCIpLnJldmVyc2UoKTtcbiAgbGV0IGN1ciA9IHB1YlN1ZjtcbiAgY29uc3QgcGVybXV0YXRpb25zID0gW2N1cl07XG4gIHdoaWxlIChwYXJ0cy5sZW5ndGgpIHtcbiAgICBjb25zdCBwYXJ0ID0gcGFydHMuc2hpZnQoKTtcbiAgICBjdXIgPSBgJHtwYXJ0fS4ke2N1cn1gO1xuICAgIHBlcm11dGF0aW9ucy5wdXNoKGN1cik7XG4gIH1cbiAgcmV0dXJuIHBlcm11dGF0aW9ucztcbn1cblxuLy8gbGliL3N0b3JlLnRzXG52YXIgU3RvcmUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgYW4gb3ZlcmxvYWQgdGhhdCBzdXBwb3J0cyB0aGUgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIGZpbmRDb29raWUoX2RvbWFpbiwgX3BhdGgsIF9rZXksIF9jYWxsYmFjaykge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpbmRDb29raWUgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgZmluZENvb2tpZXMoX2RvbWFpbiwgX3BhdGgsIF9hbGxvd1NwZWNpYWxVc2VEb21haW4gPSBmYWxzZSwgX2NhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZmluZENvb2tpZXMgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgcHV0Q29va2llKF9jb29raWUsIF9jYWxsYmFjaykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInB1dENvb2tpZSBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIGFuIG92ZXJsb2FkIHRoYXQgc3VwcG9ydHMgdGhlIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICB1cGRhdGVDb29raWUoX29sZENvb2tpZSwgX25ld0Nvb2tpZSwgX2NhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXBkYXRlQ29va2llIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgYW4gb3ZlcmxvYWQgdGhhdCBzdXBwb3J0cyB0aGUgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHJlbW92ZUNvb2tpZShfZG9tYWluLCBfcGF0aCwgX2tleSwgX2NhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmVtb3ZlQ29va2llIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgYW4gb3ZlcmxvYWQgdGhhdCBzdXBwb3J0cyB0aGUgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHJlbW92ZUNvb2tpZXMoX2RvbWFpbiwgX3BhdGgsIF9jYWxsYmFjaykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInJlbW92ZUNvb2tpZXMgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgcmVtb3ZlQWxsQ29va2llcyhfY2FsbGJhY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZW1vdmVBbGxDb29raWVzIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgYW4gb3ZlcmxvYWQgdGhhdCBzdXBwb3J0cyB0aGUgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIGdldEFsbENvb2tpZXMoX2NhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJnZXRBbGxDb29raWVzIGlzIG5vdCBpbXBsZW1lbnRlZCAodGhlcmVmb3JlIGphciBjYW5ub3QgYmUgc2VyaWFsaXplZClcIlxuICAgICk7XG4gIH1cbn07XG5cbi8vIGxpYi91dGlscy50c1xudmFyIG9iamVjdFRvU3RyaW5nID0gKG9iaikgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG52YXIgc2FmZUFycmF5VG9TdHJpbmcgPSAoYXJyLCBzZWVuQXJyYXlzKSA9PiB7XG4gIGlmICh0eXBlb2YgYXJyLmpvaW4gIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFycik7XG4gIHNlZW5BcnJheXMuYWRkKGFycik7XG4gIGNvbnN0IG1hcHBlZCA9IGFyci5tYXAoXG4gICAgKHZhbCkgPT4gdmFsID09PSBudWxsIHx8IHZhbCA9PT0gdm9pZCAwIHx8IHNlZW5BcnJheXMuaGFzKHZhbCkgPyBcIlwiIDogc2FmZVRvU3RyaW5nSW1wbCh2YWwsIHNlZW5BcnJheXMpXG4gICk7XG4gIHJldHVybiBtYXBwZWQuam9pbigpO1xufTtcbnZhciBzYWZlVG9TdHJpbmdJbXBsID0gKHZhbCwgc2VlbkFycmF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSBcIm9iamVjdFwiIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBTdHJpbmcodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsLnRvU3RyaW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gKFxuICAgICAgLy8gQXJyYXlzIGhhdmUgYSB3ZWlyZCBjdXN0b20gdG9TdHJpbmcgdGhhdCB3ZSBuZWVkIHRvIHJlcGxpY2F0ZVxuICAgICAgc2FmZUFycmF5VG9TdHJpbmcodmFsLCBzZWVuQXJyYXlzKVxuICAgICkgOiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWJhc2UtdG8tc3RyaW5nXG4gICAgICBTdHJpbmcodmFsKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHZhbCk7XG4gIH1cbn07XG52YXIgc2FmZVRvU3RyaW5nID0gKHZhbCkgPT4gc2FmZVRvU3RyaW5nSW1wbCh2YWwpO1xuZnVuY3Rpb24gY3JlYXRlUHJvbWlzZUNhbGxiYWNrKGNiKSB7XG4gIGxldCBjYWxsYmFjaztcbiAgbGV0IHJlc29sdmU7XG4gIGxldCByZWplY3Q7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcbiAgICByZXNvbHZlID0gX3Jlc29sdmU7XG4gICAgcmVqZWN0ID0gX3JlamVjdDtcbiAgfSk7XG4gIGlmICh0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNhbGxiYWNrID0gKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXJyKSBjYihlcnIpO1xuICAgICAgICBlbHNlIGNiKG51bGwsIHJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlIGluc3RhbmNlb2YgRXJyb3IgPyBlIDogbmV3IEVycm9yKCkpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2sgPSAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpO1xuICAgICAgICBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUgaW5zdGFuY2VvZiBFcnJvciA/IGUgOiBuZXcgRXJyb3IoKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgY2FsbGJhY2ssXG4gICAgcmVzb2x2ZTogKHZhbHVlKSA9PiB7XG4gICAgICBjYWxsYmFjayhudWxsLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuICAgIHJlamVjdDogKGVycm9yKSA9PiB7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpbk9wZXJhdG9yKGssIG8pIHtcbiAgcmV0dXJuIGsgaW4gbztcbn1cblxuLy8gbGliL21lbXN0b3JlLnRzXG52YXIgTWVtb3J5Q29va2llU3RvcmUgPSBjbGFzcyBleHRlbmRzIFN0b3JlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB7QGxpbmsgTWVtb3J5Q29va2llU3RvcmV9LlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICB0aGlzLmlkeCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgZmluZENvb2tpZShkb21haW4sIHBhdGgsIGtleSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBwcm9taXNlQ2FsbGJhY2sgPSBjcmVhdGVQcm9taXNlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIGlmIChkb21haW4gPT0gbnVsbCB8fCBwYXRoID09IG51bGwgfHwga2V5ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZSh2b2lkIDApO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmlkeFtkb21haW5dPy5bcGF0aF0/LltrZXldO1xuICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZShyZXN1bHQpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgZmluZENvb2tpZXMoZG9tYWluLCBwYXRoLCBhbGxvd1NwZWNpYWxVc2VEb21haW4gPSBmYWxzZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGFsbG93U3BlY2lhbFVzZURvbWFpbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjYWxsYmFjayA9IGFsbG93U3BlY2lhbFVzZURvbWFpbjtcbiAgICAgIGFsbG93U3BlY2lhbFVzZURvbWFpbiA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBjb25zdCBwcm9taXNlQ2FsbGJhY2sgPSBjcmVhdGVQcm9taXNlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIGlmICghZG9tYWluKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUoW10pO1xuICAgIH1cbiAgICBsZXQgcGF0aE1hdGNoZXI7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICBwYXRoTWF0Y2hlciA9IGZ1bmN0aW9uIG1hdGNoQWxsKGRvbWFpbkluZGV4KSB7XG4gICAgICAgIGZvciAoY29uc3QgY3VyUGF0aCBpbiBkb21haW5JbmRleCkge1xuICAgICAgICAgIGNvbnN0IHBhdGhJbmRleCA9IGRvbWFpbkluZGV4W2N1clBhdGhdO1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGhJbmRleCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXRoSW5kZXhba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aE1hdGNoZXIgPSBmdW5jdGlvbiBtYXRjaFJGQyhkb21haW5JbmRleCkge1xuICAgICAgICBmb3IgKGNvbnN0IGNvb2tpZVBhdGggaW4gZG9tYWluSW5kZXgpIHtcbiAgICAgICAgICBpZiAocGF0aE1hdGNoKHBhdGgsIGNvb2tpZVBhdGgpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSW5kZXggPSBkb21haW5JbmRleFtjb29raWVQYXRoXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGhJbmRleCkge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhdGhJbmRleFtrZXldO1xuICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBkb21haW5zID0gcGVybXV0ZURvbWFpbihkb21haW4sIGFsbG93U3BlY2lhbFVzZURvbWFpbikgfHwgW2RvbWFpbl07XG4gICAgY29uc3QgaWR4ID0gdGhpcy5pZHg7XG4gICAgZG9tYWlucy5mb3JFYWNoKChjdXJEb21haW4pID0+IHtcbiAgICAgIGNvbnN0IGRvbWFpbkluZGV4ID0gaWR4W2N1ckRvbWFpbl07XG4gICAgICBpZiAoIWRvbWFpbkluZGV4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBhdGhNYXRjaGVyKGRvbWFpbkluZGV4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUocmVzdWx0cyk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIGFuIG92ZXJsb2FkIHRoYXQgc3VwcG9ydHMgdGhlIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBwdXRDb29raWUoY29va2llLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHByb21pc2VDYWxsYmFjayA9IGNyZWF0ZVByb21pc2VDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgY29uc3QgeyBkb21haW4sIHBhdGgsIGtleSB9ID0gY29va2llO1xuICAgIGlmIChkb21haW4gPT0gbnVsbCB8fCBwYXRoID09IG51bGwgfHwga2V5ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZSh2b2lkIDApO1xuICAgIH1cbiAgICBjb25zdCBkb21haW5FbnRyeSA9IHRoaXMuaWR4W2RvbWFpbl0gPz8gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5pZHhbZG9tYWluXSA9IGRvbWFpbkVudHJ5O1xuICAgIGNvbnN0IHBhdGhFbnRyeSA9IGRvbWFpbkVudHJ5W3BhdGhdID8/IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGRvbWFpbkVudHJ5W3BhdGhdID0gcGF0aEVudHJ5O1xuICAgIHBhdGhFbnRyeVtrZXldID0gY29va2llO1xuICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZSh2b2lkIDApO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgdXBkYXRlQ29va2llKF9vbGRDb29raWUsIG5ld0Nvb2tpZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2spIHRoaXMucHV0Q29va2llKG5ld0Nvb2tpZSwgY2FsbGJhY2spO1xuICAgIGVsc2UgcmV0dXJuIHRoaXMucHV0Q29va2llKG5ld0Nvb2tpZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIGFuIG92ZXJsb2FkIHRoYXQgc3VwcG9ydHMgdGhlIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICByZW1vdmVDb29raWUoZG9tYWluLCBwYXRoLCBrZXksIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZUNhbGxiYWNrID0gY3JlYXRlUHJvbWlzZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICBkZWxldGUgdGhpcy5pZHhbZG9tYWluXT8uW3BhdGhdPy5ba2V5XTtcbiAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUodm9pZCAwKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgYW4gb3ZlcmxvYWQgdGhhdCBzdXBwb3J0cyB0aGUgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHJlbW92ZUNvb2tpZXMoZG9tYWluLCBwYXRoLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHByb21pc2VDYWxsYmFjayA9IGNyZWF0ZVByb21pc2VDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgY29uc3QgZG9tYWluRW50cnkgPSB0aGlzLmlkeFtkb21haW5dO1xuICAgIGlmIChkb21haW5FbnRyeSkge1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgZGVsZXRlIGRvbWFpbkVudHJ5W3BhdGhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuaWR4W2RvbWFpbl07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZSh2b2lkIDApO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgcmVtb3ZlQWxsQ29va2llcyhjYWxsYmFjaykge1xuICAgIGNvbnN0IHByb21pc2VDYWxsYmFjayA9IGNyZWF0ZVByb21pc2VDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgdGhpcy5pZHggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUodm9pZCAwKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgYW4gb3ZlcmxvYWQgdGhhdCBzdXBwb3J0cyB0aGUgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIGdldEFsbENvb2tpZXMoY2FsbGJhY2spIHtcbiAgICBjb25zdCBwcm9taXNlQ2FsbGJhY2sgPSBjcmVhdGVQcm9taXNlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIGNvbnN0IGNvb2tpZXMgPSBbXTtcbiAgICBjb25zdCBpZHggPSB0aGlzLmlkeDtcbiAgICBjb25zdCBkb21haW5zID0gT2JqZWN0LmtleXMoaWR4KTtcbiAgICBkb21haW5zLmZvckVhY2goKGRvbWFpbikgPT4ge1xuICAgICAgY29uc3QgZG9tYWluRW50cnkgPSBpZHhbZG9tYWluXSA/PyB7fTtcbiAgICAgIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoZG9tYWluRW50cnkpO1xuICAgICAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgICBjb25zdCBwYXRoRW50cnkgPSBkb21haW5FbnRyeVtwYXRoXSA/PyB7fTtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHBhdGhFbnRyeSk7XG4gICAgICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgY29uc3Qga2V5RW50cnkgPSBwYXRoRW50cnlba2V5XTtcbiAgICAgICAgICBpZiAoa2V5RW50cnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29va2llcy5wdXNoKGtleUVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29va2llcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICByZXR1cm4gKGEuY3JlYXRpb25JbmRleCB8fCAwKSAtIChiLmNyZWF0aW9uSW5kZXggfHwgMCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5yZXNvbHZlKGNvb2tpZXMpO1xuICB9XG59O1xuXG4vLyBsaWIvdmFsaWRhdG9ycy50c1xuZnVuY3Rpb24gaXNOb25FbXB0eVN0cmluZyhkYXRhKSB7XG4gIHJldHVybiBpc1N0cmluZyhkYXRhKSAmJiBkYXRhICE9PSBcIlwiO1xufVxuZnVuY3Rpb24gaXNFbXB0eVN0cmluZyhkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSBcIlwiIHx8IGRhdGEgaW5zdGFuY2VvZiBTdHJpbmcgJiYgZGF0YS50b1N0cmluZygpID09PSBcIlwiO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcoZGF0YSkge1xuICByZXR1cm4gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgfHwgZGF0YSBpbnN0YW5jZW9mIFN0cmluZztcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KGRhdGEpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGRhdGEpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuZnVuY3Rpb24gdmFsaWRhdGUoYm9vbCwgY2JPck1lc3NhZ2UsIG1lc3NhZ2UpIHtcbiAgaWYgKGJvb2wpIHJldHVybjtcbiAgY29uc3QgY2IgPSB0eXBlb2YgY2JPck1lc3NhZ2UgPT09IFwiZnVuY3Rpb25cIiA/IGNiT3JNZXNzYWdlIDogdm9pZCAwO1xuICBsZXQgb3B0aW9ucyA9IHR5cGVvZiBjYk9yTWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiID8gbWVzc2FnZSA6IGNiT3JNZXNzYWdlO1xuICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSBvcHRpb25zID0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbiAgY29uc3QgZXJyID0gbmV3IFBhcmFtZXRlckVycm9yKHNhZmVUb1N0cmluZyhvcHRpb25zKSk7XG4gIGlmIChjYikgY2IoZXJyKTtcbiAgZWxzZSB0aHJvdyBlcnI7XG59XG52YXIgUGFyYW1ldGVyRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbn07XG5cbi8vIGxpYi92ZXJzaW9uLnRzXG52YXIgdmVyc2lvbiA9IFwiNi4wLjBcIjtcblxuLy8gbGliL2Nvb2tpZS9jb25zdGFudHMudHNcbnZhciBQcmVmaXhTZWN1cml0eUVudW0gPSB7XG4gIFNJTEVOVDogXCJzaWxlbnRcIixcbiAgU1RSSUNUOiBcInN0cmljdFwiLFxuICBESVNBQkxFRDogXCJ1bnNhZmUtZGlzYWJsZWRcIlxufTtcbk9iamVjdC5mcmVlemUoUHJlZml4U2VjdXJpdHlFbnVtKTtcbnZhciBJUF9WNl9SRUdFWCA9IGBcblxcXFxbPyg/OlxuKD86W2EtZkEtRlxcXFxkXXsxLDR9Oil7N30oPzpbYS1mQS1GXFxcXGRdezEsNH18Oil8XG4oPzpbYS1mQS1GXFxcXGRdezEsNH06KXs2fSg/Oig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkoPzpcXFxcLig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkpezN9fDpbYS1mQS1GXFxcXGRdezEsNH18Oil8XG4oPzpbYS1mQS1GXFxcXGRdezEsNH06KXs1fSg/OjooPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKD86XFxcXC4oPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKXszfXwoPzo6W2EtZkEtRlxcXFxkXXsxLDR9KXsxLDJ9fDopfFxuKD86W2EtZkEtRlxcXFxkXXsxLDR9Oil7NH0oPzooPzo6W2EtZkEtRlxcXFxkXXsxLDR9KXswLDF9Oig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkoPzpcXFxcLig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkpezN9fCg/OjpbYS1mQS1GXFxcXGRdezEsNH0pezEsM318Oil8XG4oPzpbYS1mQS1GXFxcXGRdezEsNH06KXszfSg/Oig/OjpbYS1mQS1GXFxcXGRdezEsNH0pezAsMn06KD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSg/OlxcXFwuKD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSl7M318KD86OlthLWZBLUZcXFxcZF17MSw0fSl7MSw0fXw6KXxcbig/OlthLWZBLUZcXFxcZF17MSw0fTopezJ9KD86KD86OlthLWZBLUZcXFxcZF17MSw0fSl7MCwzfTooPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKD86XFxcXC4oPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKXszfXwoPzo6W2EtZkEtRlxcXFxkXXsxLDR9KXsxLDV9fDopfFxuKD86W2EtZkEtRlxcXFxkXXsxLDR9Oil7MX0oPzooPzo6W2EtZkEtRlxcXFxkXXsxLDR9KXswLDR9Oig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkoPzpcXFxcLig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkpezN9fCg/OjpbYS1mQS1GXFxcXGRdezEsNH0pezEsNn18Oil8XG4oPzo6KD86KD86OlthLWZBLUZcXFxcZF17MSw0fSl7MCw1fTooPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKD86XFxcXC4oPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKXszfXwoPzo6W2EtZkEtRlxcXFxkXXsxLDR9KXsxLDd9fDopKVxuKSg/OiVbMC05YS16QS1aXXsxLH0pP1xcXFxdP1xuYC5yZXBsYWNlKC9cXHMqXFwvXFwvLiokL2dtLCBcIlwiKS5yZXBsYWNlKC9cXG4vZywgXCJcIikudHJpbSgpO1xudmFyIElQX1Y2X1JFR0VYX09CSkVDVCA9IG5ldyBSZWdFeHAoYF4ke0lQX1Y2X1JFR0VYfSRgKTtcbnZhciBJUF9WNF9SRUdFWCA9IGAoPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFxcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKWA7XG52YXIgSVBfVjRfUkVHRVhfT0JKRUNUID0gbmV3IFJlZ0V4cChgXiR7SVBfVjRfUkVHRVh9JGApO1xuXG4vLyBsaWIvY29va2llL2Nhbm9uaWNhbERvbWFpbi50c1xuZnVuY3Rpb24gZG9tYWluVG9BU0NJSShkb21haW4pIHtcbiAgcmV0dXJuIG5ldyBVUkwoYGh0dHA6Ly8ke2RvbWFpbn1gKS5ob3N0bmFtZTtcbn1cbmZ1bmN0aW9uIGNhbm9uaWNhbERvbWFpbihkb21haW5OYW1lKSB7XG4gIGlmIChkb21haW5OYW1lID09IG51bGwpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCBzdHIgPSBkb21haW5OYW1lLnRyaW0oKS5yZXBsYWNlKC9eXFwuLywgXCJcIik7XG4gIGlmIChJUF9WNl9SRUdFWF9PQkpFQ1QudGVzdChzdHIpKSB7XG4gICAgaWYgKCFzdHIuc3RhcnRzV2l0aChcIltcIikpIHtcbiAgICAgIHN0ciA9IFwiW1wiICsgc3RyO1xuICAgIH1cbiAgICBpZiAoIXN0ci5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgIHN0ciA9IHN0ciArIFwiXVwiO1xuICAgIH1cbiAgICByZXR1cm4gZG9tYWluVG9BU0NJSShzdHIpLnNsaWNlKDEsIC0xKTtcbiAgfVxuICBpZiAoL1teXFx1MDAwMS1cXHUwMDdmXS8udGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIGRvbWFpblRvQVNDSUkoc3RyKTtcbiAgfVxuICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8vIGxpYi9jb29raWUvZm9ybWF0RGF0ZS50c1xuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gIHJldHVybiBkYXRlLnRvVVRDU3RyaW5nKCk7XG59XG5cbi8vIGxpYi9jb29raWUvcGFyc2VEYXRlLnRzXG52YXIgREFURV9ERUxJTSA9IC9bXFx4MDlcXHgyMC1cXHgyRlxceDNCLVxceDQwXFx4NUItXFx4NjBcXHg3Qi1cXHg3RV0vO1xudmFyIE1PTlRIX1RPX05VTSA9IHtcbiAgamFuOiAwLFxuICBmZWI6IDEsXG4gIG1hcjogMixcbiAgYXByOiAzLFxuICBtYXk6IDQsXG4gIGp1bjogNSxcbiAganVsOiA2LFxuICBhdWc6IDcsXG4gIHNlcDogOCxcbiAgb2N0OiA5LFxuICBub3Y6IDEwLFxuICBkZWM6IDExXG59O1xuZnVuY3Rpb24gcGFyc2VEaWdpdHModG9rZW4sIG1pbkRpZ2l0cywgbWF4RGlnaXRzLCB0cmFpbGluZ09LKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIHdoaWxlIChjb3VudCA8IHRva2VuLmxlbmd0aCkge1xuICAgIGNvbnN0IGMgPSB0b2tlbi5jaGFyQ29kZUF0KGNvdW50KTtcbiAgICBpZiAoYyA8PSA0NyB8fCBjID49IDU4KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY291bnQrKztcbiAgfVxuICBpZiAoY291bnQgPCBtaW5EaWdpdHMgfHwgY291bnQgPiBtYXhEaWdpdHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF0cmFpbGluZ09LICYmIGNvdW50ICE9IHRva2VuLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gcGFyc2VJbnQodG9rZW4uc2xpY2UoMCwgY291bnQpLCAxMCk7XG59XG5mdW5jdGlvbiBwYXJzZVRpbWUodG9rZW4pIHtcbiAgY29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdChcIjpcIik7XG4gIGNvbnN0IHJlc3VsdCA9IFswLCAwLCAwXTtcbiAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIGNvbnN0IHRyYWlsaW5nT0sgPSBpID09IDI7XG4gICAgY29uc3QgbnVtUGFydCA9IHBhcnRzW2ldO1xuICAgIGlmIChudW1QYXJ0ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbnVtID0gcGFyc2VEaWdpdHMobnVtUGFydCwgMSwgMiwgdHJhaWxpbmdPSyk7XG4gICAgaWYgKG51bSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc3VsdFtpXSA9IG51bTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VNb250aCh0b2tlbikge1xuICB0b2tlbiA9IFN0cmluZyh0b2tlbikuc2xpY2UoMCwgMykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0b2tlbikge1xuICAgIGNhc2UgXCJqYW5cIjpcbiAgICAgIHJldHVybiBNT05USF9UT19OVU0uamFuO1xuICAgIGNhc2UgXCJmZWJcIjpcbiAgICAgIHJldHVybiBNT05USF9UT19OVU0uZmViO1xuICAgIGNhc2UgXCJtYXJcIjpcbiAgICAgIHJldHVybiBNT05USF9UT19OVU0ubWFyO1xuICAgIGNhc2UgXCJhcHJcIjpcbiAgICAgIHJldHVybiBNT05USF9UT19OVU0uYXByO1xuICAgIGNhc2UgXCJtYXlcIjpcbiAgICAgIHJldHVybiBNT05USF9UT19OVU0ubWF5O1xuICAgIGNhc2UgXCJqdW5cIjpcbiAgICAgIHJldHVybiBNT05USF9UT19OVU0uanVuO1xuICAgIGNhc2UgXCJqdWxcIjpcbiAgICAgIHJldHVybiBNT05USF9UT19OVU0uanVsO1xuICAgIGNhc2UgXCJhdWdcIjpcbiAgICAgIHJldHVybiBNT05USF9UT19OVU0uYXVnO1xuICAgIGNhc2UgXCJzZXBcIjpcbiAgICAgIHJldHVybiBNT05USF9UT19OVU0uc2VwO1xuICAgIGNhc2UgXCJvY3RcIjpcbiAgICAgIHJldHVybiBNT05USF9UT19OVU0ub2N0O1xuICAgIGNhc2UgXCJub3ZcIjpcbiAgICAgIHJldHVybiBNT05USF9UT19OVU0ubm92O1xuICAgIGNhc2UgXCJkZWNcIjpcbiAgICAgIHJldHVybiBNT05USF9UT19OVU0uZGVjO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm47XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlRGF0ZShjb29raWVEYXRlKSB7XG4gIGlmICghY29va2llRGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0b2tlbnMgPSBjb29raWVEYXRlLnNwbGl0KERBVEVfREVMSU0pO1xuICBsZXQgaG91cjtcbiAgbGV0IG1pbnV0ZTtcbiAgbGV0IHNlY29uZDtcbiAgbGV0IGRheU9mTW9udGg7XG4gIGxldCBtb250aDtcbiAgbGV0IHllYXI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9rZW4gPSAodG9rZW5zW2ldID8/IFwiXCIpLnRyaW0oKTtcbiAgICBpZiAoIXRva2VuLmxlbmd0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzZWNvbmQgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VUaW1lKHRva2VuKTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaG91ciA9IHJlc3VsdFswXTtcbiAgICAgICAgbWludXRlID0gcmVzdWx0WzFdO1xuICAgICAgICBzZWNvbmQgPSByZXN1bHRbMl07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF5T2ZNb250aCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZURpZ2l0cyh0b2tlbiwgMSwgMiwgdHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgZGF5T2ZNb250aCA9IHJlc3VsdDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtb250aCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZU1vbnRoKHRva2VuKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICBtb250aCA9IHJlc3VsdDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh5ZWFyID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlRGlnaXRzKHRva2VuLCAyLCA0LCB0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICB5ZWFyID0gcmVzdWx0O1xuICAgICAgICBpZiAoeWVhciA+PSA3MCAmJiB5ZWFyIDw9IDk5KSB7XG4gICAgICAgICAgeWVhciArPSAxOTAwO1xuICAgICAgICB9IGVsc2UgaWYgKHllYXIgPj0gMCAmJiB5ZWFyIDw9IDY5KSB7XG4gICAgICAgICAgeWVhciArPSAyZTM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGRheU9mTW9udGggPT09IHZvaWQgMCB8fCBtb250aCA9PT0gdm9pZCAwIHx8IHllYXIgPT09IHZvaWQgMCB8fCBob3VyID09PSB2b2lkIDAgfHwgbWludXRlID09PSB2b2lkIDAgfHwgc2Vjb25kID09PSB2b2lkIDAgfHwgZGF5T2ZNb250aCA8IDEgfHwgZGF5T2ZNb250aCA+IDMxIHx8IHllYXIgPCAxNjAxIHx8IGhvdXIgPiAyMyB8fCBtaW51dGUgPiA1OSB8fCBzZWNvbmQgPiA1OSkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheU9mTW9udGgsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSk7XG59XG5cbi8vIGxpYi9jb29raWUvY29va2llLnRzXG52YXIgQ09PS0lFX09DVEVUUyA9IC9eW1xceDIxXFx4MjMtXFx4MkJcXHgyRC1cXHgzQVxceDNDLVxceDVCXFx4NUQtXFx4N0VdKyQvO1xudmFyIFBBVEhfVkFMVUUgPSAvW1xceDIwLVxceDNBXFx4M0MtXFx4N0VdKy87XG52YXIgQ09OVFJPTF9DSEFSUyA9IC9bXFx4MDAtXFx4MUZdLztcbnZhciBURVJNSU5BVE9SUyA9IFtcIlxcblwiLCBcIlxcclwiLCBcIlxcMFwiXTtcbmZ1bmN0aW9uIHRyaW1UZXJtaW5hdG9yKHN0cikge1xuICBpZiAoaXNFbXB0eVN0cmluZyhzdHIpKSByZXR1cm4gc3RyO1xuICBmb3IgKGxldCB0ID0gMDsgdCA8IFRFUk1JTkFUT1JTLmxlbmd0aDsgdCsrKSB7XG4gICAgY29uc3QgdGVybWluYXRvciA9IFRFUk1JTkFUT1JTW3RdO1xuICAgIGNvbnN0IHRlcm1pbmF0b3JJZHggPSB0ZXJtaW5hdG9yID8gc3RyLmluZGV4T2YodGVybWluYXRvcikgOiAtMTtcbiAgICBpZiAodGVybWluYXRvcklkeCAhPT0gLTEpIHtcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCB0ZXJtaW5hdG9ySWR4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29va2llUGFpcihjb29raWVQYWlyLCBsb29zZU1vZGUpIHtcbiAgY29va2llUGFpciA9IHRyaW1UZXJtaW5hdG9yKGNvb2tpZVBhaXIpO1xuICBsZXQgZmlyc3RFcSA9IGNvb2tpZVBhaXIuaW5kZXhPZihcIj1cIik7XG4gIGlmIChsb29zZU1vZGUpIHtcbiAgICBpZiAoZmlyc3RFcSA9PT0gMCkge1xuICAgICAgY29va2llUGFpciA9IGNvb2tpZVBhaXIuc3Vic3RyaW5nKDEpO1xuICAgICAgZmlyc3RFcSA9IGNvb2tpZVBhaXIuaW5kZXhPZihcIj1cIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChmaXJzdEVxIDw9IDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGxldCBjb29raWVOYW1lLCBjb29raWVWYWx1ZTtcbiAgaWYgKGZpcnN0RXEgPD0gMCkge1xuICAgIGNvb2tpZU5hbWUgPSBcIlwiO1xuICAgIGNvb2tpZVZhbHVlID0gY29va2llUGFpci50cmltKCk7XG4gIH0gZWxzZSB7XG4gICAgY29va2llTmFtZSA9IGNvb2tpZVBhaXIuc2xpY2UoMCwgZmlyc3RFcSkudHJpbSgpO1xuICAgIGNvb2tpZVZhbHVlID0gY29va2llUGFpci5zbGljZShmaXJzdEVxICsgMSkudHJpbSgpO1xuICB9XG4gIGlmIChDT05UUk9MX0NIQVJTLnRlc3QoY29va2llTmFtZSkgfHwgQ09OVFJPTF9DSEFSUy50ZXN0KGNvb2tpZVZhbHVlKSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgYyA9IG5ldyBDb29raWUoKTtcbiAgYy5rZXkgPSBjb29raWVOYW1lO1xuICBjLnZhbHVlID0gY29va2llVmFsdWU7XG4gIHJldHVybiBjO1xufVxuZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zKSB7XG4gIGlmIChpc0VtcHR5U3RyaW5nKHN0cikgfHwgIWlzU3RyaW5nKHN0cikpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHN0ciA9IHN0ci50cmltKCk7XG4gIGNvbnN0IGZpcnN0U2VtaSA9IHN0ci5pbmRleE9mKFwiO1wiKTtcbiAgY29uc3QgY29va2llUGFpciA9IGZpcnN0U2VtaSA9PT0gLTEgPyBzdHIgOiBzdHIuc2xpY2UoMCwgZmlyc3RTZW1pKTtcbiAgY29uc3QgYyA9IHBhcnNlQ29va2llUGFpcihjb29raWVQYWlyLCBvcHRpb25zPy5sb29zZSA/PyBmYWxzZSk7XG4gIGlmICghYykge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKGZpcnN0U2VtaSA9PT0gLTEpIHtcbiAgICByZXR1cm4gYztcbiAgfVxuICBjb25zdCB1bnBhcnNlZCA9IHN0ci5zbGljZShmaXJzdFNlbWkgKyAxKS50cmltKCk7XG4gIGlmICh1bnBhcnNlZC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYztcbiAgfVxuICBjb25zdCBjb29raWVfYXZzID0gdW5wYXJzZWQuc3BsaXQoXCI7XCIpO1xuICB3aGlsZSAoY29va2llX2F2cy5sZW5ndGgpIHtcbiAgICBjb25zdCBhdiA9IChjb29raWVfYXZzLnNoaWZ0KCkgPz8gXCJcIikudHJpbSgpO1xuICAgIGlmIChhdi5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBhdl9zZXAgPSBhdi5pbmRleE9mKFwiPVwiKTtcbiAgICBsZXQgYXZfa2V5LCBhdl92YWx1ZTtcbiAgICBpZiAoYXZfc2VwID09PSAtMSkge1xuICAgICAgYXZfa2V5ID0gYXY7XG4gICAgICBhdl92YWx1ZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF2X2tleSA9IGF2LnNsaWNlKDAsIGF2X3NlcCk7XG4gICAgICBhdl92YWx1ZSA9IGF2LnNsaWNlKGF2X3NlcCArIDEpO1xuICAgIH1cbiAgICBhdl9rZXkgPSBhdl9rZXkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGF2X3ZhbHVlKSB7XG4gICAgICBhdl92YWx1ZSA9IGF2X3ZhbHVlLnRyaW0oKTtcbiAgICB9XG4gICAgc3dpdGNoIChhdl9rZXkpIHtcbiAgICAgIGNhc2UgXCJleHBpcmVzXCI6XG4gICAgICAgIGlmIChhdl92YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IGV4cCA9IHBhcnNlRGF0ZShhdl92YWx1ZSk7XG4gICAgICAgICAgaWYgKGV4cCkge1xuICAgICAgICAgICAgYy5leHBpcmVzID0gZXhwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtYXgtYWdlXCI6XG4gICAgICAgIGlmIChhdl92YWx1ZSkge1xuICAgICAgICAgIGlmICgvXi0/WzAtOV0rJC8udGVzdChhdl92YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gcGFyc2VJbnQoYXZfdmFsdWUsIDEwKTtcbiAgICAgICAgICAgIGMuc2V0TWF4QWdlKGRlbHRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZG9tYWluXCI6XG4gICAgICAgIGlmIChhdl92YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IGF2X3ZhbHVlLnRyaW0oKS5yZXBsYWNlKC9eXFwuLywgXCJcIik7XG4gICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgYy5kb21haW4gPSBkb21haW4udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicGF0aFwiOlxuICAgICAgICBjLnBhdGggPSBhdl92YWx1ZSAmJiBhdl92YWx1ZVswXSA9PT0gXCIvXCIgPyBhdl92YWx1ZSA6IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNlY3VyZVwiOlxuICAgICAgICBjLnNlY3VyZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImh0dHBvbmx5XCI6XG4gICAgICAgIGMuaHR0cE9ubHkgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzYW1lc2l0ZVwiOlxuICAgICAgICBzd2l0Y2ggKGF2X3ZhbHVlID8gYXZfdmFsdWUudG9Mb3dlckNhc2UoKSA6IFwiXCIpIHtcbiAgICAgICAgICBjYXNlIFwic3RyaWN0XCI6XG4gICAgICAgICAgICBjLnNhbWVTaXRlID0gXCJzdHJpY3RcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJsYXhcIjpcbiAgICAgICAgICAgIGMuc2FtZVNpdGUgPSBcImxheFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgIGMuc2FtZVNpdGUgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjLnNhbWVTaXRlID0gdm9pZCAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjLmV4dGVuc2lvbnMgPSBjLmV4dGVuc2lvbnMgfHwgW107XG4gICAgICAgIGMuZXh0ZW5zaW9ucy5wdXNoKGF2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBjO1xufVxuZnVuY3Rpb24gZnJvbUpTT04oc3RyKSB7XG4gIGlmICghc3RyIHx8IGlzRW1wdHlTdHJpbmcoc3RyKSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IG9iajtcbiAgaWYgKHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgb2JqID0gSlNPTi5wYXJzZShzdHIpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb2JqID0gc3RyO1xuICB9XG4gIGNvbnN0IGMgPSBuZXcgQ29va2llKCk7XG4gIENvb2tpZS5zZXJpYWxpemFibGVQcm9wZXJ0aWVzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgaW5PcGVyYXRvcihwcm9wLCBvYmopKSB7XG4gICAgICBjb25zdCB2YWwgPSBvYmpbcHJvcF07XG4gICAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGluT3BlcmF0b3IocHJvcCwgY29va2llRGVmYXVsdHMpICYmIHZhbCA9PT0gY29va2llRGVmYXVsdHNbcHJvcF0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgXCJrZXlcIjpcbiAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgIGNhc2UgXCJzYW1lU2l0ZVwiOlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjW3Byb3BdID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImV4cGlyZXNcIjpcbiAgICAgICAgY2FzZSBcImNyZWF0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJsYXN0QWNjZXNzZWRcIjpcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiIHx8IHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIGNbcHJvcF0gPSBvYmpbcHJvcF0gPT0gXCJJbmZpbml0eVwiID8gXCJJbmZpbml0eVwiIDogbmV3IERhdGUodmFsKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY1twcm9wXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWF4QWdlXCI6XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgfHwgdmFsID09PSBcIkluZmluaXR5XCIgfHwgdmFsID09PSBcIi1JbmZpbml0eVwiKSB7XG4gICAgICAgICAgICBjW3Byb3BdID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRvbWFpblwiOlxuICAgICAgICBjYXNlIFwicGF0aFwiOlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY1twcm9wXSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZWN1cmVcIjpcbiAgICAgICAgY2FzZSBcImh0dHBPbmx5XCI6XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBjW3Byb3BdID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImV4dGVuc2lvbnNcIjpcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpICYmIHZhbC5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICBjW3Byb3BdID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImhvc3RPbmx5XCI6XG4gICAgICAgIGNhc2UgXCJwYXRoSXNEZWZhdWx0XCI6XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwiYm9vbGVhblwiIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY1twcm9wXSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGM7XG59XG52YXIgY29va2llRGVmYXVsdHMgPSB7XG4gIC8vIHRoZSBvcmRlciBpbiB3aGljaCB0aGUgUkZDIGhhcyB0aGVtOlxuICBrZXk6IFwiXCIsXG4gIHZhbHVlOiBcIlwiLFxuICBleHBpcmVzOiBcIkluZmluaXR5XCIsXG4gIG1heEFnZTogbnVsbCxcbiAgZG9tYWluOiBudWxsLFxuICBwYXRoOiBudWxsLFxuICBzZWN1cmU6IGZhbHNlLFxuICBodHRwT25seTogZmFsc2UsXG4gIGV4dGVuc2lvbnM6IG51bGwsXG4gIC8vIHNldCBieSB0aGUgQ29va2llSmFyOlxuICBob3N0T25seTogbnVsbCxcbiAgcGF0aElzRGVmYXVsdDogbnVsbCxcbiAgY3JlYXRpb246IG51bGwsXG4gIGxhc3RBY2Nlc3NlZDogbnVsbCxcbiAgc2FtZVNpdGU6IHZvaWQgMFxufTtcbnZhciBfQ29va2llID0gY2xhc3MgX0Nvb2tpZSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgQ29va2llIGluc3RhbmNlLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGF0dHJpYnV0ZXMgdG8gc2V0IG9uIHRoZSBjb29raWVcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMua2V5ID0gb3B0aW9ucy5rZXkgPz8gY29va2llRGVmYXVsdHMua2V5O1xuICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlID8/IGNvb2tpZURlZmF1bHRzLnZhbHVlO1xuICAgIHRoaXMuZXhwaXJlcyA9IG9wdGlvbnMuZXhwaXJlcyA/PyBjb29raWVEZWZhdWx0cy5leHBpcmVzO1xuICAgIHRoaXMubWF4QWdlID0gb3B0aW9ucy5tYXhBZ2UgPz8gY29va2llRGVmYXVsdHMubWF4QWdlO1xuICAgIHRoaXMuZG9tYWluID0gb3B0aW9ucy5kb21haW4gPz8gY29va2llRGVmYXVsdHMuZG9tYWluO1xuICAgIHRoaXMucGF0aCA9IG9wdGlvbnMucGF0aCA/PyBjb29raWVEZWZhdWx0cy5wYXRoO1xuICAgIHRoaXMuc2VjdXJlID0gb3B0aW9ucy5zZWN1cmUgPz8gY29va2llRGVmYXVsdHMuc2VjdXJlO1xuICAgIHRoaXMuaHR0cE9ubHkgPSBvcHRpb25zLmh0dHBPbmx5ID8/IGNvb2tpZURlZmF1bHRzLmh0dHBPbmx5O1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IG9wdGlvbnMuZXh0ZW5zaW9ucyA/PyBjb29raWVEZWZhdWx0cy5leHRlbnNpb25zO1xuICAgIHRoaXMuY3JlYXRpb24gPSBvcHRpb25zLmNyZWF0aW9uID8/IGNvb2tpZURlZmF1bHRzLmNyZWF0aW9uO1xuICAgIHRoaXMuaG9zdE9ubHkgPSBvcHRpb25zLmhvc3RPbmx5ID8/IGNvb2tpZURlZmF1bHRzLmhvc3RPbmx5O1xuICAgIHRoaXMucGF0aElzRGVmYXVsdCA9IG9wdGlvbnMucGF0aElzRGVmYXVsdCA/PyBjb29raWVEZWZhdWx0cy5wYXRoSXNEZWZhdWx0O1xuICAgIHRoaXMubGFzdEFjY2Vzc2VkID0gb3B0aW9ucy5sYXN0QWNjZXNzZWQgPz8gY29va2llRGVmYXVsdHMubGFzdEFjY2Vzc2VkO1xuICAgIHRoaXMuc2FtZVNpdGUgPSBvcHRpb25zLnNhbWVTaXRlID8/IGNvb2tpZURlZmF1bHRzLnNhbWVTaXRlO1xuICAgIHRoaXMuY3JlYXRpb24gPSBvcHRpb25zLmNyZWF0aW9uID8/IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNyZWF0aW9uSW5kZXhcIiwge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgLy8gaW1wb3J0YW50IGZvciBhc3NlcnQuZGVlcEVxdWFsIGNoZWNrc1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogKytfQ29va2llLmNvb2tpZXNDcmVhdGVkXG4gICAgfSk7XG4gICAgdGhpcy5jcmVhdGlvbkluZGV4ID0gX0Nvb2tpZS5jb29raWVzQ3JlYXRlZDtcbiAgfVxuICBbU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpXSgpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGhvc3RPbmx5ID0gdGhpcy5ob3N0T25seSAhPSBudWxsID8gdGhpcy5ob3N0T25seS50b1N0cmluZygpIDogXCI/XCI7XG4gICAgY29uc3QgY3JlYXRlQWdlID0gdGhpcy5jcmVhdGlvbiAmJiB0aGlzLmNyZWF0aW9uICE9PSBcIkluZmluaXR5XCIgPyBgJHtTdHJpbmcobm93IC0gdGhpcy5jcmVhdGlvbi5nZXRUaW1lKCkpfW1zYCA6IFwiP1wiO1xuICAgIGNvbnN0IGFjY2Vzc0FnZSA9IHRoaXMubGFzdEFjY2Vzc2VkICYmIHRoaXMubGFzdEFjY2Vzc2VkICE9PSBcIkluZmluaXR5XCIgPyBgJHtTdHJpbmcobm93IC0gdGhpcy5sYXN0QWNjZXNzZWQuZ2V0VGltZSgpKX1tc2AgOiBcIj9cIjtcbiAgICByZXR1cm4gYENvb2tpZT1cIiR7dGhpcy50b1N0cmluZygpfTsgaG9zdE9ubHk9JHtob3N0T25seX07IGFBZ2U9JHthY2Nlc3NBZ2V9OyBjQWdlPSR7Y3JlYXRlQWdlfVwiYDtcbiAgfVxuICAvKipcbiAgICogRm9yIGNvbnZlbmllbmNlIGluIHVzaW5nIGBKU09OLnN0cmluZ2lmeShjb29raWUpYC4gUmV0dXJucyBhIHBsYWluLW9sZCBPYmplY3QgdGhhdCBjYW4gYmUgSlNPTi1zZXJpYWxpemVkLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiAtIEFueSBgRGF0ZWAgcHJvcGVydGllcyAoc3VjaCBhcyB7QGxpbmsgQ29va2llLmV4cGlyZXN9LCB7QGxpbmsgQ29va2llLmNyZWF0aW9ufSwgYW5kIHtAbGluayBDb29raWUubGFzdEFjY2Vzc2VkfSkgYXJlIGV4cG9ydGVkIGluIElTTyBmb3JtYXQgKGBEYXRlLnRvSVNPU3RyaW5nKClgKS5cbiAgICpcbiAgICogIC0gQ3VzdG9tIENvb2tpZSBwcm9wZXJ0aWVzIGFyZSBkaXNjYXJkZWQuIEluIHRvdWdoLWNvb2tpZSAxLngsIHNpbmNlIHRoZXJlIHdhcyBubyB7QGxpbmsgQ29va2llLnRvSlNPTn0gbWV0aG9kIGV4cGxpY2l0bHkgZGVmaW5lZCwgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyB3ZXJlIGNhcHR1cmVkLlxuICAgKiAgICAgIElmIHlvdSB3YW50IGEgcHJvcGVydHkgdG8gYmUgc2VyaWFsaXplZCwgYWRkIHRoZSBwcm9wZXJ0eSBuYW1lIHRvIHtAbGluayBDb29raWUuc2VyaWFsaXphYmxlUHJvcGVydGllc30uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIF9Db29raWUuc2VyaWFsaXphYmxlUHJvcGVydGllcykge1xuICAgICAgY29uc3QgdmFsID0gdGhpc1twcm9wXTtcbiAgICAgIGlmICh2YWwgPT09IGNvb2tpZURlZmF1bHRzW3Byb3BdKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgXCJrZXlcIjpcbiAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgIGNhc2UgXCJzYW1lU2l0ZVwiOlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBvYmpbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZXhwaXJlc1wiOlxuICAgICAgICBjYXNlIFwiY3JlYXRpb25cIjpcbiAgICAgICAgY2FzZSBcImxhc3RBY2Nlc3NlZFwiOlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgfHwgdmFsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgb2JqW3Byb3BdID0gdmFsID09IFwiSW5maW5pdHlcIiA/IFwiSW5maW5pdHlcIiA6IG5ldyBEYXRlKHZhbCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqW3Byb3BdID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYXhBZ2VcIjpcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiB8fCB2YWwgPT09IFwiSW5maW5pdHlcIiB8fCB2YWwgPT09IFwiLUluZmluaXR5XCIpIHtcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkb21haW5cIjpcbiAgICAgICAgY2FzZSBcInBhdGhcIjpcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCB2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZWN1cmVcIjpcbiAgICAgICAgY2FzZSBcImh0dHBPbmx5XCI6XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBvYmpbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZXh0ZW5zaW9uc1wiOlxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJob3N0T25seVwiOlxuICAgICAgICBjYXNlIFwicGF0aElzRGVmYXVsdFwiOlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcImJvb2xlYW5cIiB8fCB2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgLyoqXG4gICAqIERvZXMgYSBkZWVwIGNsb25lIG9mIHRoaXMgY29va2llLCBpbXBsZW1lbnRlZCBleGFjdGx5IGFzIGBDb29raWUuZnJvbUpTT04oY29va2llLnRvSlNPTigpKWAuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBmcm9tSlNPTih0aGlzLnRvSlNPTigpKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGVzIGNvb2tpZSBhdHRyaWJ1dGVzIGZvciBzZW1hbnRpYyBjb3JyZWN0bmVzcy4gVXNlZnVsIGZvciBcImxpbnRcIiBjaGVja2luZyBhbnkgYFNldC1Db29raWVgIGhlYWRlcnMgeW91IGdlbmVyYXRlLlxuICAgKiBGb3Igbm93LCBpdCByZXR1cm5zIGEgYm9vbGVhbiwgYnV0IGV2ZW50dWFsbHkgY291bGQgcmV0dXJuIGEgcmVhc29uIHN0cmluZy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogV29ya3MgZm9yIGEgZmV3IHRoaW5ncywgYnV0IGlzIGJ5IG5vIG1lYW5zIGNvbXByZWhlbnNpdmUuXG4gICAqXG4gICAqIEBiZXRhXG4gICAqL1xuICB2YWxpZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMudmFsdWUgfHwgIUNPT0tJRV9PQ1RFVFMudGVzdCh0aGlzLnZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5leHBpcmVzICE9IFwiSW5maW5pdHlcIiAmJiAhKHRoaXMuZXhwaXJlcyBpbnN0YW5jZW9mIERhdGUpICYmICFwYXJzZURhdGUodGhpcy5leHBpcmVzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXhBZ2UgIT0gbnVsbCAmJiB0aGlzLm1heEFnZSAhPT0gXCJJbmZpbml0eVwiICYmICh0aGlzLm1heEFnZSA9PT0gXCItSW5maW5pdHlcIiB8fCB0aGlzLm1heEFnZSA8PSAwKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXRoICE9IG51bGwgJiYgIVBBVEhfVkFMVUUudGVzdCh0aGlzLnBhdGgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNkb21haW4gPSB0aGlzLmNkb21haW4oKTtcbiAgICBpZiAoY2RvbWFpbikge1xuICAgICAgaWYgKGNkb21haW4ubWF0Y2goL1xcLiQvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBzdWZmaXggPSBnZXRQdWJsaWNTdWZmaXgoY2RvbWFpbik7XG4gICAgICBpZiAoc3VmZml4ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgJ0V4cGlyZXMnIGF0dHJpYnV0ZSBvbiBhIGNvb2tpZS5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogV2hlbiBnaXZlbiBhIGBzdHJpbmdgIHZhbHVlIGl0IHdpbGwgYmUgcGFyc2VkIHdpdGgge0BsaW5rIHBhcnNlRGF0ZX0uIElmIHRoZSB2YWx1ZSBjYW4ndCBiZSBwYXJzZWQgYXMgYSBjb29raWUgZGF0ZVxuICAgKiB0aGVuIHRoZSAnRXhwaXJlcycgYXR0cmlidXRlIHdpbGwgYmUgc2V0IHRvIGBcIkluZmluaXR5XCJgLlxuICAgKlxuICAgKiBAcGFyYW0gZXhwIC0gdGhlIG5ldyB2YWx1ZSBmb3IgdGhlICdFeHBpcmVzJyBhdHRyaWJ1dGUgb2YgdGhlIGNvb2tpZS5cbiAgICovXG4gIHNldEV4cGlyZXMoZXhwKSB7XG4gICAgaWYgKGV4cCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHRoaXMuZXhwaXJlcyA9IGV4cDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHBpcmVzID0gcGFyc2VEYXRlKGV4cCkgfHwgXCJJbmZpbml0eVwiO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgJ01heC1BZ2UnIGF0dHJpYnV0ZSAoaW4gc2Vjb25kcykgb24gYSBjb29raWUuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIENvZXJjZXMgYC1JbmZpbml0eWAgdG8gYFwiLUluZmluaXR5XCJgIGFuZCBgSW5maW5pdHlgIHRvIGBcIkluZmluaXR5XCJgIHNvIGl0IGNhbiBiZSBzZXJpYWxpemVkIHRvIEpTT04uXG4gICAqXG4gICAqIEBwYXJhbSBhZ2UgLSB0aGUgbmV3IHZhbHVlIGZvciB0aGUgJ01heC1BZ2UnIGF0dHJpYnV0ZSAoaW4gc2Vjb25kcykuXG4gICAqL1xuICBzZXRNYXhBZ2UoYWdlKSB7XG4gICAgaWYgKGFnZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHRoaXMubWF4QWdlID0gXCJJbmZpbml0eVwiO1xuICAgIH0gZWxzZSBpZiAoYWdlID09PSAtSW5maW5pdHkpIHtcbiAgICAgIHRoaXMubWF4QWdlID0gXCItSW5maW5pdHlcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXhBZ2UgPSBhZ2U7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFbmNvZGVzIHRvIGEgYENvb2tpZWAgaGVhZGVyIHZhbHVlIChzcGVjaWZpY2FsbHksIHRoZSB7QGxpbmsgQ29va2llLmtleX0gYW5kIHtAbGluayBDb29raWUudmFsdWV9IHByb3BlcnRpZXMgam9pbmVkIHdpdGggXCI9XCIpLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjb29raWVTdHJpbmcoKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy52YWx1ZSB8fCBcIlwiO1xuICAgIGlmICh0aGlzLmtleSkge1xuICAgICAgcmV0dXJuIGAke3RoaXMua2V5fT0ke3ZhbH1gO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIC8qKlxuICAgKiBFbmNvZGVzIHRvIGEgYFNldC1Db29raWUgaGVhZGVyYCB2YWx1ZS5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IHN0ciA9IHRoaXMuY29va2llU3RyaW5nKCk7XG4gICAgaWYgKHRoaXMuZXhwaXJlcyAhPSBcIkluZmluaXR5XCIpIHtcbiAgICAgIGlmICh0aGlzLmV4cGlyZXMgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHN0ciArPSBgOyBFeHBpcmVzPSR7Zm9ybWF0RGF0ZSh0aGlzLmV4cGlyZXMpfWA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm1heEFnZSAhPSBudWxsICYmIHRoaXMubWF4QWdlICE9IEluZmluaXR5KSB7XG4gICAgICBzdHIgKz0gYDsgTWF4LUFnZT0ke1N0cmluZyh0aGlzLm1heEFnZSl9YDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZG9tYWluICYmICF0aGlzLmhvc3RPbmx5KSB7XG4gICAgICBzdHIgKz0gYDsgRG9tYWluPSR7dGhpcy5kb21haW59YDtcbiAgICB9XG4gICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgc3RyICs9IGA7IFBhdGg9JHt0aGlzLnBhdGh9YDtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2VjdXJlKSB7XG4gICAgICBzdHIgKz0gXCI7IFNlY3VyZVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5odHRwT25seSkge1xuICAgICAgc3RyICs9IFwiOyBIdHRwT25seVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5zYW1lU2l0ZSAmJiB0aGlzLnNhbWVTaXRlICE9PSBcIm5vbmVcIikge1xuICAgICAgaWYgKHRoaXMuc2FtZVNpdGUudG9Mb3dlckNhc2UoKSA9PT0gX0Nvb2tpZS5zYW1lU2l0ZUNhbm9uaWNhbC5sYXgudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBzdHIgKz0gYDsgU2FtZVNpdGU9JHtfQ29va2llLnNhbWVTaXRlQ2Fub25pY2FsLmxheH1gO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNhbWVTaXRlLnRvTG93ZXJDYXNlKCkgPT09IF9Db29raWUuc2FtZVNpdGVDYW5vbmljYWwuc3RyaWN0LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgc3RyICs9IGA7IFNhbWVTaXRlPSR7X0Nvb2tpZS5zYW1lU2l0ZUNhbm9uaWNhbC5zdHJpY3R9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciArPSBgOyBTYW1lU2l0ZT0ke3RoaXMuc2FtZVNpdGV9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZXh0ZW5zaW9ucykge1xuICAgICAgdGhpcy5leHRlbnNpb25zLmZvckVhY2goKGV4dCkgPT4ge1xuICAgICAgICBzdHIgKz0gYDsgJHtleHR9YDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgVFRMIHJlbGF0aXZlIHRvIG5vdyAobWlsbGlzZWNvbmRzKS5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogLSBgSW5maW5pdHlgIGlzIHJldHVybmVkIGZvciBjb29raWVzIHdpdGhvdXQgYW4gZXhwbGljaXQgZXhwaXJ5XG4gICAqXG4gICAqIC0gYDBgIGlzIHJldHVybmVkIGlmIHRoZSBjb29raWUgaXMgZXhwaXJlZC5cbiAgICpcbiAgICogLSBPdGhlcndpc2UgYSB0aW1lLXRvLWxpdmUgaW4gbWlsbGlzZWNvbmRzIGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0gbm93IC0gcGFzc2luZyBhbiBleHBsaWNpdCB2YWx1ZSBpcyBtb3N0bHkgdXNlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBzaW5jZSB0aGlzIGRlZmF1bHRzIHRvIHRoZSBgRGF0ZS5ub3coKWBcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgVFRMKG5vdyA9IERhdGUubm93KCkpIHtcbiAgICBpZiAodGhpcy5tYXhBZ2UgIT0gbnVsbCAmJiB0eXBlb2YgdGhpcy5tYXhBZ2UgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLm1heEFnZSA8PSAwID8gMCA6IHRoaXMubWF4QWdlICogMWUzO1xuICAgIH1cbiAgICBjb25zdCBleHBpcmVzID0gdGhpcy5leHBpcmVzO1xuICAgIGlmIChleHBpcmVzID09PSBcIkluZmluaXR5XCIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIChleHBpcmVzPy5nZXRUaW1lKCkgPz8gbm93KSAtIChub3cgfHwgRGF0ZS5ub3coKSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBhYnNvbHV0ZSB1bml4LWVwb2NoIG1pbGxpc2Vjb25kcyB0aGF0IHRoaXMgY29va2llIGV4cGlyZXMuXG4gICAqXG4gICAqIFRoZSBcIk1heC1BZ2VcIiBhdHRyaWJ1dGUgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIFwiRXhwaXJlc1wiIChhcyBwZXIgdGhlIFJGQykuIFRoZSB7QGxpbmsgQ29va2llLmxhc3RBY2Nlc3NlZH0gYXR0cmlidXRlXG4gICAqIChvciB0aGUgYG5vd2AgcGFyYW1ldGVyIGlmIGdpdmVuKSBpcyB1c2VkIHRvIG9mZnNldCB0aGUge0BsaW5rIENvb2tpZS5tYXhBZ2V9IGF0dHJpYnV0ZS5cbiAgICpcbiAgICogSWYgRXhwaXJlcyAoe0BsaW5rIENvb2tpZS5leHBpcmVzfSkgaXMgc2V0LCB0aGF0J3MgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSBub3cgLSBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGEgdGltZSBvZmZzZXQgKGluc3RlYWQgb2Yge0BsaW5rIENvb2tpZS5sYXN0QWNjZXNzZWR9KSB0byB1c2Ugd2hlbiBjYWxjdWxhdGluZyB0aGUgXCJNYXgtQWdlXCIgdmFsdWVcbiAgICovXG4gIGV4cGlyeVRpbWUobm93KSB7XG4gICAgaWYgKHRoaXMubWF4QWdlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBub3cgfHwgdGhpcy5sYXN0QWNjZXNzZWQgfHwgLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBtYXhBZ2UgPSB0eXBlb2YgdGhpcy5tYXhBZ2UgPT09IFwibnVtYmVyXCIgPyB0aGlzLm1heEFnZSA6IC1JbmZpbml0eTtcbiAgICAgIGNvbnN0IGFnZSA9IG1heEFnZSA8PSAwID8gLUluZmluaXR5IDogbWF4QWdlICogMWUzO1xuICAgICAgaWYgKHJlbGF0aXZlVG8gPT09IFwiSW5maW5pdHlcIikge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVsYXRpdmVUby5nZXRUaW1lKCkgKyBhZ2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmV4cGlyZXMgPT0gXCJJbmZpbml0eVwiKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV4cGlyZXMgPyB0aGlzLmV4cGlyZXMuZ2V0VGltZSgpIDogdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTaW1pbGFyIHRvIHtAbGluayBDb29raWUuZXhwaXJ5VGltZX0sIGNvbXB1dGVzIHRoZSBhYnNvbHV0ZSB1bml4LWVwb2NoIG1pbGxpc2Vjb25kcyB0aGF0IHRoaXMgY29va2llIGV4cGlyZXMgYW5kIHJldHVybnMgaXQgYXMgYSBEYXRlLlxuICAgKlxuICAgKiBUaGUgXCJNYXgtQWdlXCIgYXR0cmlidXRlIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBcIkV4cGlyZXNcIiAoYXMgcGVyIHRoZSBSRkMpLiBUaGUge0BsaW5rIENvb2tpZS5sYXN0QWNjZXNzZWR9IGF0dHJpYnV0ZVxuICAgKiAob3IgdGhlIGBub3dgIHBhcmFtZXRlciBpZiBnaXZlbikgaXMgdXNlZCB0byBvZmZzZXQgdGhlIHtAbGluayBDb29raWUubWF4QWdlfSBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIElmIEV4cGlyZXMgKHtAbGluayBDb29raWUuZXhwaXJlc30pIGlzIHNldCwgdGhhdCdzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0gbm93IC0gY2FuIGJlIHVzZWQgdG8gcHJvdmlkZSBhIHRpbWUgb2Zmc2V0IChpbnN0ZWFkIG9mIHtAbGluayBDb29raWUubGFzdEFjY2Vzc2VkfSkgdG8gdXNlIHdoZW4gY2FsY3VsYXRpbmcgdGhlIFwiTWF4LUFnZVwiIHZhbHVlXG4gICAqL1xuICBleHBpcnlEYXRlKG5vdykge1xuICAgIGNvbnN0IG1pbGxpc2VjID0gdGhpcy5leHBpcnlUaW1lKG5vdyk7XG4gICAgaWYgKG1pbGxpc2VjID09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKDIxNDc0ODM2NDdlMyk7XG4gICAgfSBlbHNlIGlmIChtaWxsaXNlYyA9PSAtSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaWxsaXNlYyA9PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXcgRGF0ZShtaWxsaXNlYyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNvb2tpZSBoYXMgYmVlbiBwZXJzaXN0ZWQgdG8gYSBzdG9yZSBvciBub3QuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGlzUGVyc2lzdGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhBZ2UgIT0gbnVsbCB8fCB0aGlzLmV4cGlyZXMgIT0gXCJJbmZpbml0eVwiO1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyB7QGxpbmsgY2Fub25pY2FsRG9tYWlufSB3aXRoIHRoZSB7QGxpbmsgQ29va2llLmRvbWFpbn0gcHJvcGVydHkuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNhbm9uaWNhbGl6ZWREb21haW4oKSB7XG4gICAgcmV0dXJuIGNhbm9uaWNhbERvbWFpbih0aGlzLmRvbWFpbik7XG4gIH1cbiAgLyoqXG4gICAqIEFsaWFzIGZvciB7QGxpbmsgQ29va2llLmNhbm9uaWNhbGl6ZWREb21haW59XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNkb21haW4oKSB7XG4gICAgcmV0dXJuIGNhbm9uaWNhbERvbWFpbih0aGlzLmRvbWFpbik7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHN0cmluZyBpbnRvIGEgQ29va2llIG9iamVjdC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogTm90ZTogd2hlbiBwYXJzaW5nIGEgYENvb2tpZWAgaGVhZGVyIGl0IG11c3QgYmUgc3BsaXQgYnkgJzsnIGJlZm9yZSBlYWNoIENvb2tpZSBzdHJpbmcgY2FuIGJlIHBhcnNlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgXG4gICAqIC8vIHBhcnNlIGEgYFNldC1Db29raWVgIGhlYWRlclxuICAgKiBjb25zdCBzZXRDb29raWVIZWFkZXIgPSAnYT1iY2Q7IEV4cGlyZXM9VHVlLCAxOCBPY3QgMjAxMSAwNzowNTowMyBHTVQnXG4gICAqIGNvbnN0IGNvb2tpZSA9IENvb2tpZS5wYXJzZShzZXRDb29raWVIZWFkZXIpXG4gICAqIGNvb2tpZS5rZXkgPT09ICdhJ1xuICAgKiBjb29raWUudmFsdWUgPT09ICdiY2QnXG4gICAqIGNvb2tpZS5leHBpcmVzID09PSBuZXcgRGF0ZShEYXRlLnBhcnNlKCdUdWUsIDE4IE9jdCAyMDExIDA3OjA1OjAzIEdNVCcpKVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgXG4gICAqIC8vIHBhcnNlIGEgYENvb2tpZWAgaGVhZGVyXG4gICAqIGNvbnN0IGNvb2tpZUhlYWRlciA9ICduYW1lPXZhbHVlOyBuYW1lMj12YWx1ZTI7IG5hbWUzPXZhbHVlMydcbiAgICogY29uc3QgY29va2llcyA9IGNvb2tpZUhlYWRlci5zcGxpdCgnOycpLm1hcChDb29raWUucGFyc2UpXG4gICAqIGNvb2tpZXNbMF0ubmFtZSA9PT0gJ25hbWUnXG4gICAqIGNvb2tpZXNbMF0udmFsdWUgPT09ICd2YWx1ZSdcbiAgICogY29va2llc1sxXS5uYW1lID09PSAnbmFtZTInXG4gICAqIGNvb2tpZXNbMV0udmFsdWUgPT09ICd2YWx1ZTInXG4gICAqIGNvb2tpZXNbMl0ubmFtZSA9PT0gJ25hbWUzJ1xuICAgKiBjb29raWVzWzJdLnZhbHVlID09PSAndmFsdWUzJ1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHN0ciAtIFRoZSBgU2V0LUNvb2tpZWAgaGVhZGVyIG9yIGEgQ29va2llIHN0cmluZyB0byBwYXJzZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmVzIGBzdHJpY3RgIG9yIGBsb29zZWAgbW9kZSBmb3IgY29va2llIHBhcnNpbmdcbiAgICovXG4gIHN0YXRpYyBwYXJzZShzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcGFyc2Uoc3RyLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogRG9lcyB0aGUgcmV2ZXJzZSBvZiB7QGxpbmsgQ29va2llLnRvSlNPTn0uXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIEFueSBEYXRlIHByb3BlcnRpZXMgKHN1Y2ggYXMgLmV4cGlyZXMsIC5jcmVhdGlvbiwgYW5kIC5sYXN0QWNjZXNzZWQpIGFyZSBwYXJzZWQgdmlhIERhdGUucGFyc2UsIG5vdCB0b3VnaC1jb29raWUncyBwYXJzZURhdGUsIHNpbmNlIElTTyB0aW1lc3RhbXBzIGFyZSBiZWluZyBoYW5kbGVkIGF0IHRoaXMgbGF5ZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgKiAgIGtleTogJ2FscGhhJyxcbiAgICogICB2YWx1ZTogJ2JldGEnLFxuICAgKiAgIGRvbWFpbjogJ2V4YW1wbGUuY29tJyxcbiAgICogICBwYXRoOiAnL2ZvbycsXG4gICAqICAgZXhwaXJlczogJzIwMzgtMDEtMTlUMDM6MTQ6MDcuMDAwWicsXG4gICAqIH0pXG4gICAqIGNvbnN0IGNvb2tpZSA9IENvb2tpZS5mcm9tSlNPTihqc29uKVxuICAgKiBjb29raWUua2V5ID09PSAnYWxwaGEnXG4gICAqIGNvb2tpZS52YWx1ZSA9PT0gJ2JldGEnXG4gICAqIGNvb2tpZS5kb21haW4gPT09ICdleGFtcGxlLmNvbSdcbiAgICogY29va2llLnBhdGggPT09ICcvZm9vJ1xuICAgKiBjb29raWUuZXhwaXJlcyA9PT0gbmV3IERhdGUoRGF0ZS5wYXJzZSgnMjAzOC0wMS0xOVQwMzoxNDowNy4wMDBaJykpXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gc3RyIC0gQW4gdW5wYXJzZWQgSlNPTiBzdHJpbmcgb3IgYSB2YWx1ZSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gcGFyc2VkIGFzIEpTT05cbiAgICovXG4gIHN0YXRpYyBmcm9tSlNPTihzdHIpIHtcbiAgICByZXR1cm4gZnJvbUpTT04oc3RyKTtcbiAgfVxufTtcbl9Db29raWUuY29va2llc0NyZWF0ZWQgPSAwO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuX0Nvb2tpZS5zYW1lU2l0ZUxldmVsID0ge1xuICBzdHJpY3Q6IDMsXG4gIGxheDogMixcbiAgbm9uZTogMVxufTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbl9Db29raWUuc2FtZVNpdGVDYW5vbmljYWwgPSB7XG4gIHN0cmljdDogXCJTdHJpY3RcIixcbiAgbGF4OiBcIkxheFwiXG59O1xuLyoqXG4gKiBDb29raWUgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgc2VyaWFsaXplZCB3aGVuIHVzaW5nIHtAbGluayBDb29raWUuZnJvbUpTT059IGFuZCB7QGxpbmsgQ29va2llLnRvSlNPTn0uXG4gKiBAcHVibGljXG4gKi9cbl9Db29raWUuc2VyaWFsaXphYmxlUHJvcGVydGllcyA9IFtcbiAgXCJrZXlcIixcbiAgXCJ2YWx1ZVwiLFxuICBcImV4cGlyZXNcIixcbiAgXCJtYXhBZ2VcIixcbiAgXCJkb21haW5cIixcbiAgXCJwYXRoXCIsXG4gIFwic2VjdXJlXCIsXG4gIFwiaHR0cE9ubHlcIixcbiAgXCJleHRlbnNpb25zXCIsXG4gIFwiaG9zdE9ubHlcIixcbiAgXCJwYXRoSXNEZWZhdWx0XCIsXG4gIFwiY3JlYXRpb25cIixcbiAgXCJsYXN0QWNjZXNzZWRcIixcbiAgXCJzYW1lU2l0ZVwiXG5dO1xudmFyIENvb2tpZSA9IF9Db29raWU7XG5cbi8vIGxpYi9jb29raWUvY29va2llQ29tcGFyZS50c1xudmFyIE1BWF9USU1FID0gMjE0NzQ4MzY0N2UzO1xuZnVuY3Rpb24gY29va2llQ29tcGFyZShhLCBiKSB7XG4gIGxldCBjbXA7XG4gIGNvbnN0IGFQYXRoTGVuID0gYS5wYXRoID8gYS5wYXRoLmxlbmd0aCA6IDA7XG4gIGNvbnN0IGJQYXRoTGVuID0gYi5wYXRoID8gYi5wYXRoLmxlbmd0aCA6IDA7XG4gIGNtcCA9IGJQYXRoTGVuIC0gYVBhdGhMZW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG4gIGNvbnN0IGFUaW1lID0gYS5jcmVhdGlvbiAmJiBhLmNyZWF0aW9uIGluc3RhbmNlb2YgRGF0ZSA/IGEuY3JlYXRpb24uZ2V0VGltZSgpIDogTUFYX1RJTUU7XG4gIGNvbnN0IGJUaW1lID0gYi5jcmVhdGlvbiAmJiBiLmNyZWF0aW9uIGluc3RhbmNlb2YgRGF0ZSA/IGIuY3JlYXRpb24uZ2V0VGltZSgpIDogTUFYX1RJTUU7XG4gIGNtcCA9IGFUaW1lIC0gYlRpbWU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG4gIGNtcCA9IChhLmNyZWF0aW9uSW5kZXggfHwgMCkgLSAoYi5jcmVhdGlvbkluZGV4IHx8IDApO1xuICByZXR1cm4gY21wO1xufVxuXG4vLyBsaWIvY29va2llL2RlZmF1bHRQYXRoLnRzXG5mdW5jdGlvbiBkZWZhdWx0UGF0aChwYXRoKSB7XG4gIGlmICghcGF0aCB8fCBwYXRoLnNsaWNlKDAsIDEpICE9PSBcIi9cIikge1xuICAgIHJldHVybiBcIi9cIjtcbiAgfVxuICBpZiAocGF0aCA9PT0gXCIvXCIpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBjb25zdCByaWdodFNsYXNoID0gcGF0aC5sYXN0SW5kZXhPZihcIi9cIik7XG4gIGlmIChyaWdodFNsYXNoID09PSAwKSB7XG4gICAgcmV0dXJuIFwiL1wiO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIHJpZ2h0U2xhc2gpO1xufVxuXG4vLyBsaWIvY29va2llL2RvbWFpbk1hdGNoLnRzXG52YXIgSVBfUkVHRVhfTE9XRVJDQVNFID0gLyg/Ol4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkpezN9JCl8KD86Xig/Oig/OlthLWZcXGRdezEsNH06KXs3fSg/OlthLWZcXGRdezEsNH18Oil8KD86W2EtZlxcZF17MSw0fTopezZ9KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKXszfXw6W2EtZlxcZF17MSw0fXw6KXwoPzpbYS1mXFxkXXsxLDR9Oil7NX0oPzo6KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKXszfXwoPzo6W2EtZlxcZF17MSw0fSl7MSwyfXw6KXwoPzpbYS1mXFxkXXsxLDR9Oil7NH0oPzooPzo6W2EtZlxcZF17MSw0fSl7MCwxfTooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkpezN9fCg/OjpbYS1mXFxkXXsxLDR9KXsxLDN9fDopfCg/OlthLWZcXGRdezEsNH06KXszfSg/Oig/OjpbYS1mXFxkXXsxLDR9KXswLDJ9Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSl7M318KD86OlthLWZcXGRdezEsNH0pezEsNH18Oil8KD86W2EtZlxcZF17MSw0fTopezJ9KD86KD86OlthLWZcXGRdezEsNH0pezAsM306KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKXszfXwoPzo6W2EtZlxcZF17MSw0fSl7MSw1fXw6KXwoPzpbYS1mXFxkXXsxLDR9Oil7MX0oPzooPzo6W2EtZlxcZF17MSw0fSl7MCw0fTooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkpezN9fCg/OjpbYS1mXFxkXXsxLDR9KXsxLDZ9fDopfCg/OjooPzooPzo6W2EtZlxcZF17MSw0fSl7MCw1fTooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkpezN9fCg/OjpbYS1mXFxkXXsxLDR9KXsxLDd9fDopKSkkKS87XG5mdW5jdGlvbiBkb21haW5NYXRjaChkb21haW4sIGNvb2tpZURvbWFpbiwgY2Fub25pY2FsaXplKSB7XG4gIGlmIChkb21haW4gPT0gbnVsbCB8fCBjb29raWVEb21haW4gPT0gbnVsbCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IF9zdHI7XG4gIGxldCBfZG9tU3RyO1xuICBpZiAoY2Fub25pY2FsaXplICE9PSBmYWxzZSkge1xuICAgIF9zdHIgPSBjYW5vbmljYWxEb21haW4oZG9tYWluKTtcbiAgICBfZG9tU3RyID0gY2Fub25pY2FsRG9tYWluKGNvb2tpZURvbWFpbik7XG4gIH0gZWxzZSB7XG4gICAgX3N0ciA9IGRvbWFpbjtcbiAgICBfZG9tU3RyID0gY29va2llRG9tYWluO1xuICB9XG4gIGlmIChfc3RyID09IG51bGwgfHwgX2RvbVN0ciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAoX3N0ciA9PSBfZG9tU3RyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgaWR4ID0gX3N0ci5sYXN0SW5kZXhPZihfZG9tU3RyKTtcbiAgaWYgKGlkeCA8PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChfc3RyLmxlbmd0aCAhPT0gX2RvbVN0ci5sZW5ndGggKyBpZHgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKF9zdHIuc3Vic3RyaW5nKGlkeCAtIDEsIGlkeCkgIT09IFwiLlwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAhSVBfUkVHRVhfTE9XRVJDQVNFLnRlc3QoX3N0cik7XG59XG5cbi8vIGxpYi9jb29raWUvc2VjdXJlQ29udGV4dC50c1xuZnVuY3Rpb24gaXNMb29wYmFja1Y0KGFkZHJlc3MpIHtcbiAgY29uc3Qgb2N0ZXRzID0gYWRkcmVzcy5zcGxpdChcIi5cIik7XG4gIHJldHVybiBvY3RldHMubGVuZ3RoID09PSA0ICYmIG9jdGV0c1swXSAhPT0gdm9pZCAwICYmIHBhcnNlSW50KG9jdGV0c1swXSwgMTApID09PSAxMjc7XG59XG5mdW5jdGlvbiBpc0xvb3BiYWNrVjYoYWRkcmVzcykge1xuICByZXR1cm4gYWRkcmVzcyA9PT0gXCI6OjFcIjtcbn1cbmZ1bmN0aW9uIGlzTm9ybWFsaXplZExvY2FsaG9zdFRMRChsb3dlckhvc3QpIHtcbiAgcmV0dXJuIGxvd2VySG9zdC5lbmRzV2l0aChcIi5sb2NhbGhvc3RcIik7XG59XG5mdW5jdGlvbiBpc0xvY2FsSG9zdG5hbWUoaG9zdCkge1xuICBjb25zdCBsb3dlckhvc3QgPSBob3N0LnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBsb3dlckhvc3QgPT09IFwibG9jYWxob3N0XCIgfHwgaXNOb3JtYWxpemVkTG9jYWxob3N0VExEKGxvd2VySG9zdCk7XG59XG5mdW5jdGlvbiBob3N0Tm9CcmFja2V0cyhob3N0KSB7XG4gIGlmIChob3N0Lmxlbmd0aCA+PSAyICYmIGhvc3Quc3RhcnRzV2l0aChcIltcIikgJiYgaG9zdC5lbmRzV2l0aChcIl1cIikpIHtcbiAgICByZXR1cm4gaG9zdC5zdWJzdHJpbmcoMSwgaG9zdC5sZW5ndGggLSAxKTtcbiAgfVxuICByZXR1cm4gaG9zdDtcbn1cbmZ1bmN0aW9uIGlzUG90ZW50aWFsbHlUcnVzdHdvcnRoeShpbnB1dFVybCwgYWxsb3dTZWN1cmVPbkxvY2FsID0gdHJ1ZSkge1xuICBsZXQgdXJsO1xuICBpZiAodHlwZW9mIGlucHV0VXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIHVybCA9IG5ldyBVUkwoaW5wdXRVcmwpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB1cmwgPSBpbnB1dFVybDtcbiAgfVxuICBjb25zdCBzY2hlbWUgPSB1cmwucHJvdG9jb2wucmVwbGFjZShcIjpcIiwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgaG9zdG5hbWUgPSBob3N0Tm9CcmFja2V0cyh1cmwuaG9zdG5hbWUpLnJlcGxhY2UoL1xcLiskLywgXCJcIik7XG4gIGlmIChzY2hlbWUgPT09IFwiaHR0cHNcIiB8fCBzY2hlbWUgPT09IFwid3NzXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIWFsbG93U2VjdXJlT25Mb2NhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoSVBfVjRfUkVHRVhfT0JKRUNULnRlc3QoaG9zdG5hbWUpKSB7XG4gICAgcmV0dXJuIGlzTG9vcGJhY2tWNChob3N0bmFtZSk7XG4gIH1cbiAgaWYgKElQX1Y2X1JFR0VYX09CSkVDVC50ZXN0KGhvc3RuYW1lKSkge1xuICAgIHJldHVybiBpc0xvb3BiYWNrVjYoaG9zdG5hbWUpO1xuICB9XG4gIHJldHVybiBpc0xvY2FsSG9zdG5hbWUoaG9zdG5hbWUpO1xufVxuXG4vLyBsaWIvY29va2llL2Nvb2tpZUphci50c1xudmFyIGRlZmF1bHRTZXRDb29raWVPcHRpb25zID0ge1xuICBsb29zZTogZmFsc2UsXG4gIHNhbWVTaXRlQ29udGV4dDogdm9pZCAwLFxuICBpZ25vcmVFcnJvcjogZmFsc2UsXG4gIGh0dHA6IHRydWVcbn07XG52YXIgZGVmYXVsdEdldENvb2tpZU9wdGlvbnMgPSB7XG4gIGh0dHA6IHRydWUsXG4gIGV4cGlyZTogdHJ1ZSxcbiAgYWxsUGF0aHM6IGZhbHNlLFxuICBzYW1lU2l0ZUNvbnRleHQ6IHZvaWQgMCxcbiAgc29ydDogdm9pZCAwXG59O1xudmFyIFNBTUVfU0lURV9DT05URVhUX1ZBTF9FUlIgPSAnSW52YWxpZCBzYW1lU2l0ZUNvbnRleHQgb3B0aW9uIGZvciBnZXRDb29raWVzKCk7IGV4cGVjdGVkIG9uZSBvZiBcInN0cmljdFwiLCBcImxheFwiLCBvciBcIm5vbmVcIic7XG5mdW5jdGlvbiBnZXRDb29raWVDb250ZXh0KHVybCkge1xuICBpZiAodXJsICYmIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgJiYgXCJob3N0bmFtZVwiIGluIHVybCAmJiB0eXBlb2YgdXJsLmhvc3RuYW1lID09PSBcInN0cmluZ1wiICYmIFwicGF0aG5hbWVcIiBpbiB1cmwgJiYgdHlwZW9mIHVybC5wYXRobmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBcInByb3RvY29sXCIgaW4gdXJsICYmIHR5cGVvZiB1cmwucHJvdG9jb2wgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaG9zdG5hbWU6IHVybC5ob3N0bmFtZSxcbiAgICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsXG4gICAgICBwcm90b2NvbDogdXJsLnByb3RvY29sXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgVVJMKGRlY29kZVVSSSh1cmwpKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBuZXcgVVJMKHVybCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBQYXJhbWV0ZXJFcnJvcihcImB1cmxgIGFyZ3VtZW50IGlzIG5vdCBhIHN0cmluZyBvciBVUkwuXCIpO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja1NhbWVTaXRlQ29udGV4dCh2YWx1ZSkge1xuICBjb25zdCBjb250ZXh0ID0gU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoY29udGV4dCA9PT0gXCJub25lXCIgfHwgY29udGV4dCA9PT0gXCJsYXhcIiB8fCBjb250ZXh0ID09PSBcInN0cmljdFwiKSB7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gaXNTZWN1cmVQcmVmaXhDb25kaXRpb25NZXQoY29va2llKSB7XG4gIGNvbnN0IHN0YXJ0c1dpdGhTZWN1cmVQcmVmaXggPSB0eXBlb2YgY29va2llLmtleSA9PT0gXCJzdHJpbmdcIiAmJiBjb29raWUua2V5LnN0YXJ0c1dpdGgoXCJfX1NlY3VyZS1cIik7XG4gIHJldHVybiAhc3RhcnRzV2l0aFNlY3VyZVByZWZpeCB8fCBjb29raWUuc2VjdXJlO1xufVxuZnVuY3Rpb24gaXNIb3N0UHJlZml4Q29uZGl0aW9uTWV0KGNvb2tpZSkge1xuICBjb25zdCBzdGFydHNXaXRoSG9zdFByZWZpeCA9IHR5cGVvZiBjb29raWUua2V5ID09PSBcInN0cmluZ1wiICYmIGNvb2tpZS5rZXkuc3RhcnRzV2l0aChcIl9fSG9zdC1cIik7XG4gIHJldHVybiAhc3RhcnRzV2l0aEhvc3RQcmVmaXggfHwgQm9vbGVhbihcbiAgICBjb29raWUuc2VjdXJlICYmIGNvb2tpZS5ob3N0T25seSAmJiBjb29raWUucGF0aCAhPSBudWxsICYmIGNvb2tpZS5wYXRoID09PSBcIi9cIlxuICApO1xufVxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZFByZWZpeFNlY3VyaXR5KHByZWZpeFNlY3VyaXR5KSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRQcmVmaXhTZWN1cml0eSA9IHByZWZpeFNlY3VyaXR5LnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAobm9ybWFsaXplZFByZWZpeFNlY3VyaXR5KSB7XG4gICAgY2FzZSBQcmVmaXhTZWN1cml0eUVudW0uU1RSSUNUOlxuICAgIGNhc2UgUHJlZml4U2VjdXJpdHlFbnVtLlNJTEVOVDpcbiAgICBjYXNlIFByZWZpeFNlY3VyaXR5RW51bS5ESVNBQkxFRDpcbiAgICAgIHJldHVybiBub3JtYWxpemVkUHJlZml4U2VjdXJpdHk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBQcmVmaXhTZWN1cml0eUVudW0uU0lMRU5UO1xuICB9XG59XG52YXIgQ29va2llSmFyID0gY2xhc3MgX0Nvb2tpZUphciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBDb29raWVKYXJgIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiAtIElmIGEgY3VzdG9tIHN0b3JlIGlzIG5vdCBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLCBhbiBpbi1tZW1vcnkgc3RvcmUgKHtAbGluayBNZW1vcnlDb29raWVTdG9yZX0gd2lsbCBiZSBjcmVhdGVkIGFuZCB1c2VkLlxuICAgKiAtIElmIGEgYm9vbGVhbiB2YWx1ZSBpcyBwYXNzZWQgYXMgdGhlIGBvcHRpb25zYCBwYXJhbWV0ZXIsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBwYXNzaW5nIGB7IHJlamVjdFB1YmxpY1N1ZmZpeGVzOiA8dmFsdWU+IH1gXG4gICAqXG4gICAqIEBwYXJhbSBzdG9yZSAtIGEgY3VzdG9tIHtAbGluayBTdG9yZX0gaW1wbGVtZW50YXRpb24gKGRlZmF1bHRzIHRvIHtAbGluayBNZW1vcnlDb29raWVTdG9yZX0pXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gY29uZmlndXJlcyBob3cgY29va2llcyBhcmUgcHJvY2Vzc2VkIGJ5IHRoZSBjb29raWUgamFyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzdG9yZSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIG9wdGlvbnMgPSB7IHJlamVjdFB1YmxpY1N1ZmZpeGVzOiBvcHRpb25zIH07XG4gICAgfVxuICAgIHRoaXMucmVqZWN0UHVibGljU3VmZml4ZXMgPSBvcHRpb25zPy5yZWplY3RQdWJsaWNTdWZmaXhlcyA/PyB0cnVlO1xuICAgIHRoaXMuZW5hYmxlTG9vc2VNb2RlID0gb3B0aW9ucz8ubG9vc2VNb2RlID8/IGZhbHNlO1xuICAgIHRoaXMuYWxsb3dTcGVjaWFsVXNlRG9tYWluID0gb3B0aW9ucz8uYWxsb3dTcGVjaWFsVXNlRG9tYWluID8/IHRydWU7XG4gICAgdGhpcy5hbGxvd1NlY3VyZU9uTG9jYWwgPSBvcHRpb25zPy5hbGxvd1NlY3VyZU9uTG9jYWwgPz8gdHJ1ZTtcbiAgICB0aGlzLnByZWZpeFNlY3VyaXR5ID0gZ2V0Tm9ybWFsaXplZFByZWZpeFNlY3VyaXR5KFxuICAgICAgb3B0aW9ucz8ucHJlZml4U2VjdXJpdHkgPz8gXCJzaWxlbnRcIlxuICAgICk7XG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlID8/IG5ldyBNZW1vcnlDb29raWVTdG9yZSgpO1xuICB9XG4gIGNhbGxTeW5jKGZuKSB7XG4gICAgaWYgKCF0aGlzLnN0b3JlLnN5bmNocm9ub3VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ29va2llSmFyIHN0b3JlIGlzIG5vdCBzeW5jaHJvbm91czsgdXNlIGFzeW5jIEFQSSBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgc3luY0VyciA9IG51bGw7XG4gICAgbGV0IHN5bmNSZXN1bHQgPSB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIGZuLmNhbGwodGhpcywgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgc3luY0VyciA9IGVycm9yO1xuICAgICAgICBzeW5jUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzeW5jRXJyID0gZXJyO1xuICAgIH1cbiAgICBpZiAoc3luY0VycikgdGhyb3cgc3luY0VycjtcbiAgICByZXR1cm4gc3luY1Jlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgdGhlIG92ZXJsb2FkIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBzZXRDb29raWUoY29va2llLCB1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2VDYWxsYmFjayA9IGNyZWF0ZVByb21pc2VDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgY29uc3QgY2IgPSBwcm9taXNlQ2FsbGJhY2suY2FsbGJhY2s7XG4gICAgbGV0IGNvbnRleHQ7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbGlkYXRlKFxuICAgICAgICAgIGlzTm9uRW1wdHlTdHJpbmcodXJsKSxcbiAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICBzYWZlVG9TdHJpbmcob3B0aW9ucylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQgPSBnZXRDb29raWVDb250ZXh0KHVybCk7XG4gICAgICBpZiAodHlwZW9mIHVybCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVqZWN0KG5ldyBFcnJvcihcIk5vIFVSTCB3YXMgc3BlY2lmaWVkXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0U2V0Q29va2llT3B0aW9ucztcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRlKHR5cGVvZiBjYiA9PT0gXCJmdW5jdGlvblwiLCBjYik7XG4gICAgICBpZiAoIWlzTm9uRW1wdHlTdHJpbmcoY29va2llKSAmJiAhaXNPYmplY3QoY29va2llKSAmJiBjb29raWUgaW5zdGFuY2VvZiBTdHJpbmcgJiYgY29va2llLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZSh2b2lkIDApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5yZWplY3QoZXJyKTtcbiAgICB9XG4gICAgY29uc3QgaG9zdCA9IGNhbm9uaWNhbERvbWFpbihjb250ZXh0Lmhvc3RuYW1lKSA/PyBudWxsO1xuICAgIGNvbnN0IGxvb3NlID0gb3B0aW9ucz8ubG9vc2UgfHwgdGhpcy5lbmFibGVMb29zZU1vZGU7XG4gICAgbGV0IHNhbWVTaXRlQ29udGV4dCA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnM/LnNhbWVTaXRlQ29udGV4dCkge1xuICAgICAgc2FtZVNpdGVDb250ZXh0ID0gY2hlY2tTYW1lU2l0ZUNvbnRleHQob3B0aW9ucy5zYW1lU2l0ZUNvbnRleHQpO1xuICAgICAgaWYgKCFzYW1lU2l0ZUNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5yZWplY3QobmV3IEVycm9yKFNBTUVfU0lURV9DT05URVhUX1ZBTF9FUlIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb29raWUgPT09IFwic3RyaW5nXCIgfHwgY29va2llIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICBjb25zdCBwYXJzZWRDb29raWUgPSBDb29raWUucGFyc2UoY29va2llLnRvU3RyaW5nKCksIHsgbG9vc2UgfSk7XG4gICAgICBpZiAoIXBhcnNlZENvb2tpZSkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXCJDb29raWUgZmFpbGVkIHRvIHBhcnNlXCIpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucz8uaWdub3JlRXJyb3IgPyBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZSh2b2lkIDApIDogcHJvbWlzZUNhbGxiYWNrLnJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgY29va2llID0gcGFyc2VkQ29va2llO1xuICAgIH0gZWxzZSBpZiAoIShjb29raWUgaW5zdGFuY2VvZiBDb29raWUpKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgIFwiRmlyc3QgYXJndW1lbnQgdG8gc2V0Q29va2llIG11c3QgYmUgYSBDb29raWUgb2JqZWN0IG9yIHN0cmluZ1wiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG9wdGlvbnM/Lmlnbm9yZUVycm9yID8gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUodm9pZCAwKSA6IHByb21pc2VDYWxsYmFjay5yZWplY3QoZXJyKTtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gb3B0aW9ucz8ubm93IHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGlmICh0aGlzLnJlamVjdFB1YmxpY1N1ZmZpeGVzICYmIGNvb2tpZS5kb21haW4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNkb21haW4gPSBjb29raWUuY2RvbWFpbigpO1xuICAgICAgICBjb25zdCBzdWZmaXggPSB0eXBlb2YgY2RvbWFpbiA9PT0gXCJzdHJpbmdcIiA/IGdldFB1YmxpY1N1ZmZpeChjZG9tYWluLCB7XG4gICAgICAgICAgYWxsb3dTcGVjaWFsVXNlRG9tYWluOiB0aGlzLmFsbG93U3BlY2lhbFVzZURvbWFpbixcbiAgICAgICAgICBpZ25vcmVFcnJvcjogb3B0aW9ucz8uaWdub3JlRXJyb3JcbiAgICAgICAgfSkgOiBudWxsO1xuICAgICAgICBpZiAoc3VmZml4ID09IG51bGwgJiYgIUlQX1Y2X1JFR0VYX09CSkVDVC50ZXN0KGNvb2tpZS5kb21haW4pKSB7XG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFwiQ29va2llIGhhcyBkb21haW4gc2V0IHRvIGEgcHVibGljIHN1ZmZpeFwiKTtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucz8uaWdub3JlRXJyb3IgPyBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZSh2b2lkIDApIDogcHJvbWlzZUNhbGxiYWNrLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM/Lmlnbm9yZUVycm9yID8gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUodm9pZCAwKSA6IChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgIHByb21pc2VDYWxsYmFjay5yZWplY3QoZXJyKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29va2llLmRvbWFpbikge1xuICAgICAgaWYgKCFkb21haW5NYXRjaChob3N0ID8/IHZvaWQgMCwgY29va2llLmNkb21haW4oKSA/PyB2b2lkIDAsIGZhbHNlKSkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgYENvb2tpZSBub3QgaW4gdGhpcyBob3N0J3MgZG9tYWluLiBDb29raWU6JHtjb29raWUuY2RvbWFpbigpID8/IFwibnVsbFwifSBSZXF1ZXN0OiR7aG9zdCA/PyBcIm51bGxcIn1gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBvcHRpb25zPy5pZ25vcmVFcnJvciA/IHByb21pc2VDYWxsYmFjay5yZXNvbHZlKHZvaWQgMCkgOiBwcm9taXNlQ2FsbGJhY2sucmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICBpZiAoY29va2llLmhvc3RPbmx5ID09IG51bGwpIHtcbiAgICAgICAgY29va2llLmhvc3RPbmx5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvb2tpZS5ob3N0T25seSA9IHRydWU7XG4gICAgICBjb29raWUuZG9tYWluID0gaG9zdDtcbiAgICB9XG4gICAgaWYgKCFjb29raWUucGF0aCB8fCBjb29raWUucGF0aFswXSAhPT0gXCIvXCIpIHtcbiAgICAgIGNvb2tpZS5wYXRoID0gZGVmYXVsdFBhdGgoY29udGV4dC5wYXRobmFtZSk7XG4gICAgICBjb29raWUucGF0aElzRGVmYXVsdCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5odHRwID09PSBmYWxzZSAmJiBjb29raWUuaHR0cE9ubHkpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcIkNvb2tpZSBpcyBIdHRwT25seSBhbmQgdGhpcyBpc24ndCBhbiBIVFRQIEFQSVwiKTtcbiAgICAgIHJldHVybiBvcHRpb25zLmlnbm9yZUVycm9yID8gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUodm9pZCAwKSA6IHByb21pc2VDYWxsYmFjay5yZWplY3QoZXJyKTtcbiAgICB9XG4gICAgaWYgKGNvb2tpZS5zYW1lU2l0ZSAhPT0gXCJub25lXCIgJiYgY29va2llLnNhbWVTaXRlICE9PSB2b2lkIDAgJiYgc2FtZVNpdGVDb250ZXh0KSB7XG4gICAgICBpZiAoc2FtZVNpdGVDb250ZXh0ID09PSBcIm5vbmVcIikge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDb29raWUgaXMgU2FtZVNpdGUgYnV0IHRoaXMgaXMgYSBjcm9zcy1vcmlnaW4gcmVxdWVzdFwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBvcHRpb25zPy5pZ25vcmVFcnJvciA/IHByb21pc2VDYWxsYmFjay5yZXNvbHZlKHZvaWQgMCkgOiBwcm9taXNlQ2FsbGJhY2sucmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlnbm9yZUVycm9yRm9yUHJlZml4U2VjdXJpdHkgPSB0aGlzLnByZWZpeFNlY3VyaXR5ID09PSBQcmVmaXhTZWN1cml0eUVudW0uU0lMRU5UO1xuICAgIGNvbnN0IHByZWZpeFNlY3VyaXR5RGlzYWJsZWQgPSB0aGlzLnByZWZpeFNlY3VyaXR5ID09PSBQcmVmaXhTZWN1cml0eUVudW0uRElTQUJMRUQ7XG4gICAgaWYgKCFwcmVmaXhTZWN1cml0eURpc2FibGVkKSB7XG4gICAgICBsZXQgZXJyb3JGb3VuZCA9IGZhbHNlO1xuICAgICAgbGV0IGVycm9yTXNnO1xuICAgICAgaWYgKCFpc1NlY3VyZVByZWZpeENvbmRpdGlvbk1ldChjb29raWUpKSB7XG4gICAgICAgIGVycm9yRm91bmQgPSB0cnVlO1xuICAgICAgICBlcnJvck1zZyA9IFwiQ29va2llIGhhcyBfX1NlY3VyZSBwcmVmaXggYnV0IFNlY3VyZSBhdHRyaWJ1dGUgaXMgbm90IHNldFwiO1xuICAgICAgfSBlbHNlIGlmICghaXNIb3N0UHJlZml4Q29uZGl0aW9uTWV0KGNvb2tpZSkpIHtcbiAgICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgICAgIGVycm9yTXNnID0gXCJDb29raWUgaGFzIF9fSG9zdCBwcmVmaXggYnV0IGVpdGhlciBTZWN1cmUgb3IgSG9zdE9ubHkgYXR0cmlidXRlIGlzIG5vdCBzZXQgb3IgUGF0aCBpcyBub3QgJy8nXCI7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3JGb3VuZCkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucz8uaWdub3JlRXJyb3IgfHwgaWdub3JlRXJyb3JGb3JQcmVmaXhTZWN1cml0eSA/IHByb21pc2VDYWxsYmFjay5yZXNvbHZlKHZvaWQgMCkgOiBwcm9taXNlQ2FsbGJhY2sucmVqZWN0KG5ldyBFcnJvcihlcnJvck1zZykpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgaWYgKCFzdG9yZS51cGRhdGVDb29raWUpIHtcbiAgICAgIHN0b3JlLnVwZGF0ZUNvb2tpZSA9IGFzeW5jIGZ1bmN0aW9uKF9vbGRDb29raWUsIG5ld0Nvb2tpZSwgY2IyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dENvb2tpZShuZXdDb29raWUpLnRoZW4oXG4gICAgICAgICAgKCkgPT4gY2IyPy4obnVsbCksXG4gICAgICAgICAgKGVycm9yKSA9PiBjYjI/LihlcnJvcilcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHdpdGhDb29raWUgPSBmdW5jdGlvbiB3aXRoQ29va2llMihlcnIsIG9sZENvb2tpZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYihlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0ID0gZnVuY3Rpb24oZXJyMikge1xuICAgICAgICBpZiAoZXJyMikge1xuICAgICAgICAgIGNiKGVycjIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb29raWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjYihudWxsLCB2b2lkIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKG51bGwsIGNvb2tpZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAob2xkQ29va2llKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIFwiaHR0cFwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5odHRwID09PSBmYWxzZSAmJiBvbGRDb29raWUuaHR0cE9ubHkpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoXCJvbGQgQ29va2llIGlzIEh0dHBPbmx5IGFuZCB0aGlzIGlzbid0IGFuIEhUVFAgQVBJXCIpO1xuICAgICAgICAgIGlmIChvcHRpb25zLmlnbm9yZUVycm9yKSBjYihudWxsLCB2b2lkIDApO1xuICAgICAgICAgIGVsc2UgY2IoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvb2tpZSBpbnN0YW5jZW9mIENvb2tpZSkge1xuICAgICAgICAgIGNvb2tpZS5jcmVhdGlvbiA9IG9sZENvb2tpZS5jcmVhdGlvbjtcbiAgICAgICAgICBjb29raWUuY3JlYXRpb25JbmRleCA9IG9sZENvb2tpZS5jcmVhdGlvbkluZGV4O1xuICAgICAgICAgIGNvb2tpZS5sYXN0QWNjZXNzZWQgPSBub3c7XG4gICAgICAgICAgc3RvcmUudXBkYXRlQ29va2llKG9sZENvb2tpZSwgY29va2llLCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvb2tpZSBpbnN0YW5jZW9mIENvb2tpZSkge1xuICAgICAgICAgIGNvb2tpZS5jcmVhdGlvbiA9IGNvb2tpZS5sYXN0QWNjZXNzZWQgPSBub3c7XG4gICAgICAgICAgc3RvcmUucHV0Q29va2llKGNvb2tpZSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHN0b3JlLmZpbmRDb29raWUoY29va2llLmRvbWFpbiwgY29va2llLnBhdGgsIGNvb2tpZS5rZXksIHdpdGhDb29raWUpO1xuICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogU3luY2hyb25vdXNseSBhdHRlbXB0IHRvIHNldCB0aGUge0BsaW5rIENvb2tpZX0gaW4gdGhlIHtAbGluayBDb29raWVKYXJ9LlxuICAgKlxuICAgKiA8c3Ryb25nPk5vdGU6PC9zdHJvbmc+IE9ubHkgd29ya3MgaWYgdGhlIGNvbmZpZ3VyZWQge0BsaW5rIFN0b3JlfSBpcyBhbHNvIHN5bmNocm9ub3VzLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiAtIElmIHN1Y2Nlc3NmdWxseSBwZXJzaXN0ZWQsIHRoZSB7QGxpbmsgQ29va2llfSB3aWxsIGhhdmUgdXBkYXRlZFxuICAgKiAgICAge0BsaW5rIENvb2tpZS5jcmVhdGlvbn0sIHtAbGluayBDb29raWUubGFzdEFjY2Vzc2VkfSBhbmQge0BsaW5rIENvb2tpZS5ob3N0T25seX1cbiAgICogICAgIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIC0gQXMgcGVyIHRoZSBSRkMsIHRoZSB7QGxpbmsgQ29va2llLmhvc3RPbmx5fSBmbGFnIGlzIHNldCBpZiB0aGVyZSB3YXMgbm8gYERvbWFpbj17dmFsdWV9YFxuICAgKiAgICAgYXR0cmlidXRlIG9uIHRoZSBjb29raWUgc3RyaW5nLiBUaGUge0BsaW5rIENvb2tpZS5kb21haW59IHByb3BlcnR5IGlzIHNldCB0byB0aGVcbiAgICogICAgIGZ1bGx5LXF1YWxpZmllZCBob3N0bmFtZSBvZiBgY3VycmVudFVybGAgaW4gdGhpcyBjYXNlLiBNYXRjaGluZyB0aGlzIGNvb2tpZSByZXF1aXJlcyBhblxuICAgKiAgICAgZXhhY3QgaG9zdG5hbWUgbWF0Y2ggKG5vdCBhIHtAbGluayBkb21haW5NYXRjaH0gYXMgcGVyIHVzdWFsKVxuICAgKlxuICAgKiBAcGFyYW0gY29va2llIC0gVGhlIGNvb2tpZSBvYmplY3Qgb3IgY29va2llIHN0cmluZyB0byBzdG9yZS4gQSBzdHJpbmcgdmFsdWUgd2lsbCBiZSBwYXJzZWQgaW50byBhIGNvb2tpZSB1c2luZyB7QGxpbmsgQ29va2llLnBhcnNlfS5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBkb21haW4gdG8gc3RvcmUgdGhlIGNvb2tpZSB3aXRoLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gc2V0dGluZ3MgdG8gdXNlIHdoZW4gc3RvcmluZyB0aGUgY29va2llLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZXRDb29raWVTeW5jKGNvb2tpZSwgdXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc2V0Q29va2llRm4gPSBvcHRpb25zID8gdGhpcy5zZXRDb29raWUuYmluZCh0aGlzLCBjb29raWUsIHVybCwgb3B0aW9ucykgOiB0aGlzLnNldENvb2tpZS5iaW5kKHRoaXMsIGNvb2tpZSwgdXJsKTtcbiAgICByZXR1cm4gdGhpcy5jYWxsU3luYyhzZXRDb29raWVGbik7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIHRoZSBvdmVybG9hZCBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgZ2V0Q29va2llcyh1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0R2V0Q29va2llT3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRHZXRDb29raWVPcHRpb25zO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlQ2FsbGJhY2sgPSBjcmVhdGVQcm9taXNlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIGNvbnN0IGNiID0gcHJvbWlzZUNhbGxiYWNrLmNhbGxiYWNrO1xuICAgIGxldCBjb250ZXh0O1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWxpZGF0ZShpc05vbkVtcHR5U3RyaW5nKHVybCksIGNiLCB1cmwpO1xuICAgICAgfVxuICAgICAgY29udGV4dCA9IGdldENvb2tpZUNvbnRleHQodXJsKTtcbiAgICAgIHZhbGlkYXRlKFxuICAgICAgICBpc09iamVjdChvcHRpb25zKSxcbiAgICAgICAgY2IsXG4gICAgICAgIHNhZmVUb1N0cmluZyhvcHRpb25zKVxuICAgICAgKTtcbiAgICAgIHZhbGlkYXRlKHR5cGVvZiBjYiA9PT0gXCJmdW5jdGlvblwiLCBjYik7XG4gICAgfSBjYXRjaCAocGFyYW1ldGVyRXJyb3IpIHtcbiAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVqZWN0KHBhcmFtZXRlckVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgaG9zdCA9IGNhbm9uaWNhbERvbWFpbihjb250ZXh0Lmhvc3RuYW1lKTtcbiAgICBjb25zdCBwYXRoID0gY29udGV4dC5wYXRobmFtZSB8fCBcIi9cIjtcbiAgICBjb25zdCBwb3RlbnRpYWxseVRydXN0d29ydGh5ID0gaXNQb3RlbnRpYWxseVRydXN0d29ydGh5KFxuICAgICAgdXJsLFxuICAgICAgdGhpcy5hbGxvd1NlY3VyZU9uTG9jYWxcbiAgICApO1xuICAgIGxldCBzYW1lU2l0ZUxldmVsID0gMDtcbiAgICBpZiAob3B0aW9ucy5zYW1lU2l0ZUNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHNhbWVTaXRlQ29udGV4dCA9IGNoZWNrU2FtZVNpdGVDb250ZXh0KG9wdGlvbnMuc2FtZVNpdGVDb250ZXh0KTtcbiAgICAgIGlmIChzYW1lU2l0ZUNvbnRleHQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlamVjdChuZXcgRXJyb3IoU0FNRV9TSVRFX0NPTlRFWFRfVkFMX0VSUikpO1xuICAgICAgfVxuICAgICAgc2FtZVNpdGVMZXZlbCA9IENvb2tpZS5zYW1lU2l0ZUxldmVsW3NhbWVTaXRlQ29udGV4dF07XG4gICAgICBpZiAoIXNhbWVTaXRlTGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5yZWplY3QobmV3IEVycm9yKFNBTUVfU0lURV9DT05URVhUX1ZBTF9FUlIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaHR0cCA9IG9wdGlvbnMuaHR0cCA/PyB0cnVlO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZXhwaXJlQ2hlY2sgPSBvcHRpb25zLmV4cGlyZSA/PyB0cnVlO1xuICAgIGNvbnN0IGFsbFBhdGhzID0gb3B0aW9ucy5hbGxQYXRocyA/PyBmYWxzZTtcbiAgICBjb25zdCBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgZnVuY3Rpb24gbWF0Y2hpbmdDb29raWUoYykge1xuICAgICAgaWYgKGMuaG9zdE9ubHkpIHtcbiAgICAgICAgaWYgKGMuZG9tYWluICE9IGhvc3QpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZG9tYWluTWF0Y2goaG9zdCA/PyB2b2lkIDAsIGMuZG9tYWluID8/IHZvaWQgMCwgZmFsc2UpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWFsbFBhdGhzICYmIHR5cGVvZiBjLnBhdGggPT09IFwic3RyaW5nXCIgJiYgIXBhdGhNYXRjaChwYXRoLCBjLnBhdGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjLnNlY3VyZSAmJiAhcG90ZW50aWFsbHlUcnVzdHdvcnRoeSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoYy5odHRwT25seSAmJiAhaHR0cCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc2FtZVNpdGVMZXZlbCkge1xuICAgICAgICBsZXQgY29va2llTGV2ZWw7XG4gICAgICAgIGlmIChjLnNhbWVTaXRlID09PSBcImxheFwiKSB7XG4gICAgICAgICAgY29va2llTGV2ZWwgPSBDb29raWUuc2FtZVNpdGVMZXZlbC5sYXg7XG4gICAgICAgIH0gZWxzZSBpZiAoYy5zYW1lU2l0ZSA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgICAgIGNvb2tpZUxldmVsID0gQ29va2llLnNhbWVTaXRlTGV2ZWwuc3RyaWN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvb2tpZUxldmVsID0gQ29va2llLnNhbWVTaXRlTGV2ZWwubm9uZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29va2llTGV2ZWwgPiBzYW1lU2l0ZUxldmVsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBleHBpcnlUaW1lID0gYy5leHBpcnlUaW1lKCk7XG4gICAgICBpZiAoZXhwaXJlQ2hlY2sgJiYgZXhwaXJ5VGltZSAhPSB2b2lkIDAgJiYgZXhwaXJ5VGltZSA8PSBub3cpIHtcbiAgICAgICAgc3RvcmUucmVtb3ZlQ29va2llKGMuZG9tYWluLCBjLnBhdGgsIGMua2V5LCAoKSA9PiB7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3RvcmUuZmluZENvb2tpZXMoXG4gICAgICBob3N0LFxuICAgICAgYWxsUGF0aHMgPyBudWxsIDogcGF0aCxcbiAgICAgIHRoaXMuYWxsb3dTcGVjaWFsVXNlRG9tYWluLFxuICAgICAgKGVyciwgY29va2llcykgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvb2tpZXMgPT0gbnVsbCkge1xuICAgICAgICAgIGNiKG51bGwsIFtdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29va2llcyA9IGNvb2tpZXMuZmlsdGVyKG1hdGNoaW5nQ29va2llKTtcbiAgICAgICAgaWYgKFwic29ydFwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5zb3J0ICE9PSBmYWxzZSkge1xuICAgICAgICAgIGNvb2tpZXMgPSBjb29raWVzLnNvcnQoY29va2llQ29tcGFyZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm93MiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGNvb2tpZSBvZiBjb29raWVzKSB7XG4gICAgICAgICAgY29va2llLmxhc3RBY2Nlc3NlZCA9IG5vdzI7XG4gICAgICAgIH1cbiAgICAgICAgY2IobnVsbCwgY29va2llcyk7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzbHkgcmV0cmlldmUgdGhlIGxpc3Qgb2YgY29va2llcyB0aGF0IGNhbiBiZSBzZW50IGluIGEgQ29va2llIGhlYWRlciBmb3IgdGhlXG4gICAqIGN1cnJlbnQgVVJMLlxuICAgKlxuICAgKiA8c3Ryb25nPk5vdGU8L3N0cm9uZz46IE9ubHkgd29ya3MgaWYgdGhlIGNvbmZpZ3VyZWQgU3RvcmUgaXMgYWxzbyBzeW5jaHJvbm91cy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogLSBUaGUgYXJyYXkgb2YgY29va2llcyByZXR1cm5lZCB3aWxsIGJlIHNvcnRlZCBhY2NvcmRpbmcgdG8ge0BsaW5rIGNvb2tpZUNvbXBhcmV9LlxuICAgKlxuICAgKiAtIFRoZSB7QGxpbmsgQ29va2llLmxhc3RBY2Nlc3NlZH0gcHJvcGVydHkgd2lsbCBiZSB1cGRhdGVkIG9uIGFsbCByZXR1cm5lZCBjb29raWVzLlxuICAgKlxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIGRvbWFpbiB0byBzdG9yZSB0aGUgY29va2llIHdpdGguXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBzZXR0aW5ncyB0byB1c2Ugd2hlbiByZXRyaWV2aW5nIHRoZSBjb29raWVzLlxuICAgKi9cbiAgZ2V0Q29va2llc1N5bmModXJsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbFN5bmModGhpcy5nZXRDb29raWVzLmJpbmQodGhpcywgdXJsLCBvcHRpb25zKSkgPz8gW107XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIHRoZSBvdmVybG9hZCBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgZ2V0Q29va2llU3RyaW5nKHVybCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZUNhbGxiYWNrID0gY3JlYXRlUHJvbWlzZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICBjb25zdCBuZXh0ID0gZnVuY3Rpb24oZXJyLCBjb29raWVzKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VDYWxsYmFjay5jYWxsYmFjayhlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZUNhbGxiYWNrLmNhbGxiYWNrKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgY29va2llcz8uc29ydChjb29raWVDb21wYXJlKS5tYXAoKGMpID0+IGMuY29va2llU3RyaW5nKCkpLmpvaW4oXCI7IFwiKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRDb29raWVzKHVybCwgb3B0aW9ucywgbmV4dCk7XG4gICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5wcm9taXNlO1xuICB9XG4gIC8qKlxuICAgKiBTeW5jaHJvbm91cyB2ZXJzaW9uIG9mIGAuZ2V0Q29va2llU3RyaW5nKClgLiBBY2NlcHRzIHRoZSBzYW1lIG9wdGlvbnMgYXMgYC5nZXRDb29raWVzKClgIGJ1dCByZXR1cm5zIGEgc3RyaW5nIHN1aXRhYmxlIGZvciBhXG4gICAqIGBDb29raWVgIGhlYWRlciByYXRoZXIgdGhhbiBhbiBBcnJheS5cbiAgICpcbiAgICogPHN0cm9uZz5Ob3RlPC9zdHJvbmc+OiBPbmx5IHdvcmtzIGlmIHRoZSBjb25maWd1cmVkIFN0b3JlIGlzIGFsc28gc3luY2hyb25vdXMuXG4gICAqXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgZG9tYWluIHRvIHN0b3JlIHRoZSBjb29raWUgd2l0aC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIHNldHRpbmdzIHRvIHVzZSB3aGVuIHJldHJpZXZpbmcgdGhlIGNvb2tpZXMuXG4gICAqL1xuICBnZXRDb29raWVTdHJpbmdTeW5jKHVybCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNhbGxTeW5jKFxuICAgICAgb3B0aW9ucyA/IHRoaXMuZ2V0Q29va2llU3RyaW5nLmJpbmQodGhpcywgdXJsLCBvcHRpb25zKSA6IHRoaXMuZ2V0Q29va2llU3RyaW5nLmJpbmQodGhpcywgdXJsKVxuICAgICkgPz8gXCJcIjtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgdGhlIG92ZXJsb2FkIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBnZXRTZXRDb29raWVTdHJpbmdzKHVybCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZUNhbGxiYWNrID0gY3JlYXRlUHJvbWlzZUNhbGxiYWNrKFxuICAgICAgY2FsbGJhY2tcbiAgICApO1xuICAgIGNvbnN0IG5leHQgPSBmdW5jdGlvbihlcnIsIGNvb2tpZXMpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZUNhbGxiYWNrLmNhbGxiYWNrKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlQ2FsbGJhY2suY2FsbGJhY2soXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBjb29raWVzPy5tYXAoKGMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjLnRvU3RyaW5nKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2V0Q29va2llcyh1cmwsIG9wdGlvbnMsIG5leHQpO1xuICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogU3luY2hyb25vdXMgdmVyc2lvbiBvZiBgLmdldFNldENvb2tpZVN0cmluZ3MoKWAuIFJldHVybnMgYW4gYXJyYXkgb2Ygc3RyaW5ncyBzdWl0YWJsZSBmb3IgYFNldC1Db29raWVgIGhlYWRlcnMuXG4gICAqIEFjY2VwdHMgdGhlIHNhbWUgb3B0aW9ucyBhcyBgLmdldENvb2tpZXMoKWAuXG4gICAqXG4gICAqIDxzdHJvbmc+Tm90ZTwvc3Ryb25nPjogT25seSB3b3JrcyBpZiB0aGUgY29uZmlndXJlZCBTdG9yZSBpcyBhbHNvIHN5bmNocm9ub3VzLlxuICAgKlxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIGRvbWFpbiB0byBzdG9yZSB0aGUgY29va2llIHdpdGguXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBzZXR0aW5ncyB0byB1c2Ugd2hlbiByZXRyaWV2aW5nIHRoZSBjb29raWVzLlxuICAgKi9cbiAgZ2V0U2V0Q29va2llU3RyaW5nc1N5bmModXJsLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsU3luYyh0aGlzLmdldFNldENvb2tpZVN0cmluZ3MuYmluZCh0aGlzLCB1cmwsIG9wdGlvbnMpKSA/PyBbXTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgdGhlIG92ZXJsb2FkIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBzZXJpYWxpemUoY2FsbGJhY2spIHtcbiAgICBjb25zdCBwcm9taXNlQ2FsbGJhY2sgPSBjcmVhdGVQcm9taXNlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIGxldCB0eXBlID0gdGhpcy5zdG9yZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChpc09iamVjdCh0eXBlKSkge1xuICAgICAgdHlwZSA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICAvLyBUaGUgdmVyc2lvbiBvZiB0b3VnaC1jb29raWUgdGhhdCBzZXJpYWxpemVkIHRoaXMgamFyLiBHZW5lcmFsbHkgYSBnb29kXG4gICAgICAvLyBwcmFjdGljZSBzaW5jZSBmdXR1cmUgdmVyc2lvbnMgY2FuIG1ha2UgZGF0YSBpbXBvcnQgZGVjaXNpb25zIGJhc2VkIG9uXG4gICAgICAvLyBrbm93biBwYXN0IGJlaGF2aW9yLiBXaGVuL2lmIHRoaXMgbWF0dGVycywgdXNlIGBzZW12ZXJgLlxuICAgICAgdmVyc2lvbjogYHRvdWdoLWNvb2tpZUAke3ZlcnNpb259YCxcbiAgICAgIC8vIGFkZCB0aGUgc3RvcmUgdHlwZSwgdG8gbWFrZSBodW1hbnMgaGFwcHk6XG4gICAgICBzdG9yZVR5cGU6IHR5cGUsXG4gICAgICAvLyBDb29raWVKYXIgY29uZmlndXJhdGlvbjpcbiAgICAgIHJlamVjdFB1YmxpY1N1ZmZpeGVzOiB0aGlzLnJlamVjdFB1YmxpY1N1ZmZpeGVzLFxuICAgICAgZW5hYmxlTG9vc2VNb2RlOiB0aGlzLmVuYWJsZUxvb3NlTW9kZSxcbiAgICAgIGFsbG93U3BlY2lhbFVzZURvbWFpbjogdGhpcy5hbGxvd1NwZWNpYWxVc2VEb21haW4sXG4gICAgICBwcmVmaXhTZWN1cml0eTogZ2V0Tm9ybWFsaXplZFByZWZpeFNlY3VyaXR5KHRoaXMucHJlZml4U2VjdXJpdHkpLFxuICAgICAgLy8gdGhpcyBnZXRzIGZpbGxlZCBmcm9tIGdldEFsbENvb2tpZXM6XG4gICAgICBjb29raWVzOiBbXVxuICAgIH07XG4gICAgaWYgKHR5cGVvZiB0aGlzLnN0b3JlLmdldEFsbENvb2tpZXMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5yZWplY3QoXG4gICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICBcInN0b3JlIGRvZXMgbm90IHN1cHBvcnQgZ2V0QWxsQ29va2llcyBhbmQgY2Fubm90IGJlIHNlcmlhbGl6ZWRcIlxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnN0b3JlLmdldEFsbENvb2tpZXMoKGVyciwgY29va2llcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlQ2FsbGJhY2suY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNvb2tpZXMgPT0gbnVsbCkge1xuICAgICAgICBwcm9taXNlQ2FsbGJhY2suY2FsbGJhY2sobnVsbCwgc2VyaWFsaXplZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlcmlhbGl6ZWQuY29va2llcyA9IGNvb2tpZXMubWFwKChjb29raWUpID0+IHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZENvb2tpZSA9IGNvb2tpZS50b0pTT04oKTtcbiAgICAgICAgZGVsZXRlIHNlcmlhbGl6ZWRDb29raWUuY3JlYXRpb25JbmRleDtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRDb29raWU7XG4gICAgICB9KTtcbiAgICAgIHByb21pc2VDYWxsYmFjay5jYWxsYmFjayhudWxsLCBzZXJpYWxpemVkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgQ29va2llSmFyIGlmIHRoZSB1bmRlcmx5aW5nIHN0b3JlIHN1cHBvcnRzIGAuZ2V0QWxsQ29va2llc2AuXG4gICAqXG4gICAqIDxzdHJvbmc+Tm90ZTwvc3Ryb25nPjogT25seSB3b3JrcyBpZiB0aGUgY29uZmlndXJlZCBTdG9yZSBpcyBhbHNvIHN5bmNocm9ub3VzLlxuICAgKi9cbiAgc2VyaWFsaXplU3luYygpIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsU3luYygoY2FsbGJhY2spID0+IHtcbiAgICAgIHRoaXMuc2VyaWFsaXplKGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWxpYXMgb2Yge0BsaW5rIENvb2tpZUphci5zZXJpYWxpemVTeW5jfS4gQWxsb3dzIHRoZSBjb29raWUgdG8gYmUgc2VyaWFsaXplZFxuICAgKiB3aXRoIGBKU09OLnN0cmluZ2lmeShjb29raWVKYXIpYC5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVTeW5jKCk7XG4gIH1cbiAgLyoqXG4gICAqIFVzZSB0aGUgY2xhc3MgbWV0aG9kIENvb2tpZUphci5kZXNlcmlhbGl6ZSBpbnN0ZWFkIG9mIGNhbGxpbmcgdGhpcyBkaXJlY3RseVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9pbXBvcnRDb29raWVzKHNlcmlhbGl6ZWQsIGNhbGxiYWNrKSB7XG4gICAgbGV0IGNvb2tpZXMgPSB2b2lkIDA7XG4gICAgaWYgKHNlcmlhbGl6ZWQgJiYgdHlwZW9mIHNlcmlhbGl6ZWQgPT09IFwib2JqZWN0XCIgJiYgaW5PcGVyYXRvcihcImNvb2tpZXNcIiwgc2VyaWFsaXplZCkgJiYgQXJyYXkuaXNBcnJheShzZXJpYWxpemVkLmNvb2tpZXMpKSB7XG4gICAgICBjb29raWVzID0gc2VyaWFsaXplZC5jb29raWVzO1xuICAgIH1cbiAgICBpZiAoIWNvb2tpZXMpIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcInNlcmlhbGl6ZWQgamFyIGhhcyBubyBjb29raWVzIGFycmF5XCIpLCB2b2lkIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb29raWVzID0gY29va2llcy5zbGljZSgpO1xuICAgIGNvbnN0IHB1dE5leHQgPSAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgdm9pZCAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29va2llcykpIHtcbiAgICAgICAgaWYgKCFjb29raWVzLmxlbmd0aCkge1xuICAgICAgICAgIGNhbGxiYWNrKGVyciwgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb29raWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29va2llID0gQ29va2llLmZyb21KU09OKGNvb2tpZXMuc2hpZnQoKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjYWxsYmFjayhlIGluc3RhbmNlb2YgRXJyb3IgPyBlIDogbmV3IEVycm9yKCksIHZvaWQgMCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb29raWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHB1dE5leHQobnVsbCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcmUucHV0Q29va2llKGNvb2tpZSwgcHV0TmV4dCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBwdXROZXh0KG51bGwpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9pbXBvcnRDb29raWVzU3luYyhzZXJpYWxpemVkKSB7XG4gICAgdGhpcy5jYWxsU3luYyh0aGlzLl9pbXBvcnRDb29raWVzLmJpbmQodGhpcywgc2VyaWFsaXplZCkpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyB0aGUgb3ZlcmxvYWQgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIGNsb25lKG5ld1N0b3JlLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgbmV3U3RvcmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2FsbGJhY2sgPSBuZXdTdG9yZTtcbiAgICAgIG5ld1N0b3JlID0gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlQ2FsbGJhY2sgPSBjcmVhdGVQcm9taXNlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIGNvbnN0IGNiID0gcHJvbWlzZUNhbGxiYWNrLmNhbGxiYWNrO1xuICAgIHRoaXMuc2VyaWFsaXplKChlcnIsIHNlcmlhbGl6ZWQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5yZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfQ29va2llSmFyLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWQgPz8gXCJcIiwgbmV3U3RvcmUsIGNiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2Nsb25lU3luYyhuZXdTdG9yZSkge1xuICAgIGNvbnN0IGNsb25lRm4gPSBuZXdTdG9yZSAmJiB0eXBlb2YgbmV3U3RvcmUgIT09IFwiZnVuY3Rpb25cIiA/IHRoaXMuY2xvbmUuYmluZCh0aGlzLCBuZXdTdG9yZSkgOiB0aGlzLmNsb25lLmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuY2FsbFN5bmMoKGNhbGxiYWNrKSA9PiB7XG4gICAgICBjbG9uZUZuKGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHJvZHVjZXMgYSBkZWVwIGNsb25lIG9mIHRoaXMgQ29va2llSmFyLiBNb2RpZmljYXRpb25zIHRvIHRoZSBvcmlnaW5hbCBkb1xuICAgKiBub3QgYWZmZWN0IHRoZSBjbG9uZSwgYW5kIHZpY2UgdmVyc2EuXG4gICAqXG4gICAqIDxzdHJvbmc+Tm90ZTwvc3Ryb25nPjogT25seSB3b3JrcyBpZiBib3RoIHRoZSBjb25maWd1cmVkIFN0b3JlIGFuZCBkZXN0aW5hdGlvblxuICAgKiBTdG9yZSBhcmUgc3luY2hyb25vdXMuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIC0gV2hlbiBubyB7QGxpbmsgU3RvcmV9IGlzIHByb3ZpZGVkLCBhIG5ldyB7QGxpbmsgTWVtb3J5Q29va2llU3RvcmV9IHdpbGwgYmUgdXNlZC5cbiAgICpcbiAgICogLSBUcmFuc2ZlcnJpbmcgYmV0d2VlbiBzdG9yZSB0eXBlcyBpcyBzdXBwb3J0ZWQgc28gbG9uZyBhcyB0aGUgc291cmNlXG4gICAqICAgICBpbXBsZW1lbnRzIGAuZ2V0QWxsQ29va2llcygpYCBhbmQgdGhlIGRlc3RpbmF0aW9uIGltcGxlbWVudHMgYC5wdXRDb29raWUoKWAuXG4gICAqXG4gICAqIEBwYXJhbSBuZXdTdG9yZSAtIFRoZSB0YXJnZXQge0BsaW5rIFN0b3JlfSB0byBjbG9uZSBjb29raWVzIGludG8uXG4gICAqL1xuICBjbG9uZVN5bmMobmV3U3RvcmUpIHtcbiAgICBpZiAoIW5ld1N0b3JlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2xvbmVTeW5jKCk7XG4gICAgfVxuICAgIGlmICghbmV3U3RvcmUuc3luY2hyb25vdXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDb29raWVKYXIgY2xvbmUgZGVzdGluYXRpb24gc3RvcmUgaXMgbm90IHN5bmNocm9ub3VzOyB1c2UgYXN5bmMgQVBJIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbG9uZVN5bmMobmV3U3RvcmUpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyB0aGUgb3ZlcmxvYWQgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHJlbW92ZUFsbENvb2tpZXMoY2FsbGJhY2spIHtcbiAgICBjb25zdCBwcm9taXNlQ2FsbGJhY2sgPSBjcmVhdGVQcm9taXNlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIGNvbnN0IGNiID0gcHJvbWlzZUNhbGxiYWNrLmNhbGxiYWNrO1xuICAgIGNvbnN0IHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICBpZiAodHlwZW9mIHN0b3JlLnJlbW92ZUFsbENvb2tpZXMgPT09IFwiZnVuY3Rpb25cIiAmJiBzdG9yZS5yZW1vdmVBbGxDb29raWVzICE9PSBTdG9yZS5wcm90b3R5cGUucmVtb3ZlQWxsQ29va2llcykge1xuICAgICAgc3RvcmUucmVtb3ZlQWxsQ29va2llcyhjYik7XG4gICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnByb21pc2U7XG4gICAgfVxuICAgIHN0b3JlLmdldEFsbENvb2tpZXMoKGVyciwgY29va2llcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYihlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWNvb2tpZXMpIHtcbiAgICAgICAgY29va2llcyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGNvb2tpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNiKG51bGwsIHZvaWQgMCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBjb21wbGV0ZWRDb3VudCA9IDA7XG4gICAgICBjb25zdCByZW1vdmVFcnJvcnMgPSBbXTtcbiAgICAgIGNvbnN0IHJlbW92ZUNvb2tpZUNiID0gZnVuY3Rpb24gcmVtb3ZlQ29va2llQ2IyKHJlbW92ZUVycikge1xuICAgICAgICBpZiAocmVtb3ZlRXJyKSB7XG4gICAgICAgICAgcmVtb3ZlRXJyb3JzLnB1c2gocmVtb3ZlRXJyKTtcbiAgICAgICAgfVxuICAgICAgICBjb21wbGV0ZWRDb3VudCsrO1xuICAgICAgICBpZiAoY29tcGxldGVkQ291bnQgPT09IGNvb2tpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHJlbW92ZUVycm9yc1swXSkgY2IocmVtb3ZlRXJyb3JzWzBdKTtcbiAgICAgICAgICBlbHNlIGNiKG51bGwsIHZvaWQgMCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29va2llcy5mb3JFYWNoKChjb29raWUpID0+IHtcbiAgICAgICAgc3RvcmUucmVtb3ZlQ29va2llKFxuICAgICAgICAgIGNvb2tpZS5kb21haW4sXG4gICAgICAgICAgY29va2llLnBhdGgsXG4gICAgICAgICAgY29va2llLmtleSxcbiAgICAgICAgICByZW1vdmVDb29raWVDYlxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5wcm9taXNlO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBjb29raWVzIGZyb20gdGhlIENvb2tpZUphci5cbiAgICpcbiAgICogPHN0cm9uZz5Ob3RlPC9zdHJvbmc+OiBPbmx5IHdvcmtzIGlmIHRoZSBjb25maWd1cmVkIFN0b3JlIGlzIGFsc28gc3luY2hyb25vdXMuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIC0gVGhpcyBpcyBhIG5ldyBiYWNrd2FyZHMtY29tcGF0aWJsZSBmZWF0dXJlIG9mIHRvdWdoLWNvb2tpZSB2ZXJzaW9uIDIuNSxcbiAgICogICAgIHNvIG5vdCBhbGwgU3RvcmVzIHdpbGwgaW1wbGVtZW50IGl0IGVmZmljaWVudGx5LiBGb3IgU3RvcmVzIHRoYXQgZG8gbm90XG4gICAqICAgICBpbXBsZW1lbnQgYHJlbW92ZUFsbENvb2tpZXNgLCB0aGUgZmFsbGJhY2sgaXMgdG8gY2FsbCBgcmVtb3ZlQ29va2llYCBhZnRlclxuICAgKiAgICAgYGdldEFsbENvb2tpZXNgLlxuICAgKlxuICAgKiAtIElmIGBnZXRBbGxDb29raWVzYCBmYWlscyBvciBpc24ndCBpbXBsZW1lbnRlZCBpbiB0aGUgU3RvcmUsIGFuIGVycm9yIGlzIHJldHVybmVkLlxuICAgKlxuICAgKiAtIElmIG9uZSBvciBtb3JlIG9mIHRoZSBgcmVtb3ZlQ29va2llYCBjYWxscyBmYWlsLCBvbmx5IHRoZSBmaXJzdCBlcnJvciBpcyByZXR1cm5lZC5cbiAgICovXG4gIHJlbW92ZUFsbENvb2tpZXNTeW5jKCkge1xuICAgIHRoaXMuY2FsbFN5bmMoKGNhbGxiYWNrKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZUFsbENvb2tpZXMoY2FsbGJhY2spO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyB0aGUgb3ZlcmxvYWQgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShzdHJPck9iaiwgc3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBzdG9yZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjYWxsYmFjayA9IHN0b3JlO1xuICAgICAgc3RvcmUgPSB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2VDYWxsYmFjayA9IGNyZWF0ZVByb21pc2VDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgbGV0IHNlcmlhbGl6ZWQ7XG4gICAgaWYgKHR5cGVvZiBzdHJPck9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VyaWFsaXplZCA9IEpTT04ucGFyc2Uoc3RyT3JPYmopO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlamVjdChlIGluc3RhbmNlb2YgRXJyb3IgPyBlIDogbmV3IEVycm9yKCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkID0gc3RyT3JPYmo7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRTZXJpYWxpemVkUHJvcGVydHkgPSAocHJvcGVydHkpID0+IHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkICYmIHR5cGVvZiBzZXJpYWxpemVkID09PSBcIm9iamVjdFwiICYmIGluT3BlcmF0b3IocHJvcGVydHksIHNlcmlhbGl6ZWQpID8gc2VyaWFsaXplZFtwcm9wZXJ0eV0gOiB2b2lkIDA7XG4gICAgfTtcbiAgICBjb25zdCByZWFkU2VyaWFsaXplZEJvb2xlYW4gPSAocHJvcGVydHkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcmVhZFNlcmlhbGl6ZWRQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiA/IHZhbHVlIDogdm9pZCAwO1xuICAgIH07XG4gICAgY29uc3QgcmVhZFNlcmlhbGl6ZWRTdHJpbmcgPSAocHJvcGVydHkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcmVhZFNlcmlhbGl6ZWRQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUgOiB2b2lkIDA7XG4gICAgfTtcbiAgICBjb25zdCBqYXIgPSBuZXcgX0Nvb2tpZUphcihzdG9yZSwge1xuICAgICAgcmVqZWN0UHVibGljU3VmZml4ZXM6IHJlYWRTZXJpYWxpemVkQm9vbGVhbihcInJlamVjdFB1YmxpY1N1ZmZpeGVzXCIpLFxuICAgICAgbG9vc2VNb2RlOiByZWFkU2VyaWFsaXplZEJvb2xlYW4oXCJlbmFibGVMb29zZU1vZGVcIiksXG4gICAgICBhbGxvd1NwZWNpYWxVc2VEb21haW46IHJlYWRTZXJpYWxpemVkQm9vbGVhbihcImFsbG93U3BlY2lhbFVzZURvbWFpblwiKSxcbiAgICAgIHByZWZpeFNlY3VyaXR5OiBnZXROb3JtYWxpemVkUHJlZml4U2VjdXJpdHkoXG4gICAgICAgIHJlYWRTZXJpYWxpemVkU3RyaW5nKFwicHJlZml4U2VjdXJpdHlcIikgPz8gXCJzaWxlbnRcIlxuICAgICAgKVxuICAgIH0pO1xuICAgIGphci5faW1wb3J0Q29va2llcyhzZXJpYWxpemVkLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VDYWxsYmFjay5jYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwcm9taXNlQ2FsbGJhY2suY2FsbGJhY2sobnVsbCwgamFyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIEEgbmV3IENvb2tpZUphciBpcyBjcmVhdGVkIGFuZCB0aGUgc2VyaWFsaXplZCB7QGxpbmsgQ29va2llfSB2YWx1ZXMgYXJlIGFkZGVkIHRvXG4gICAqIHRoZSB1bmRlcmx5aW5nIHN0b3JlLiBFYWNoIHtAbGluayBDb29raWV9IGlzIGFkZGVkIHZpYSBgc3RvcmUucHV0Q29va2llKC4uLilgIGluXG4gICAqIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFwcGVhciBpbiB0aGUgc2VyaWFsaXphdGlvbi5cbiAgICpcbiAgICogPHN0cm9uZz5Ob3RlPC9zdHJvbmc+OiBPbmx5IHdvcmtzIGlmIHRoZSBjb25maWd1cmVkIFN0b3JlIGlzIGFsc28gc3luY2hyb25vdXMuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIC0gV2hlbiBubyB7QGxpbmsgU3RvcmV9IGlzIHByb3ZpZGVkLCBhIG5ldyB7QGxpbmsgTWVtb3J5Q29va2llU3RvcmV9IHdpbGwgYmUgdXNlZC5cbiAgICpcbiAgICogLSBBcyBhIGNvbnZlbmllbmNlLCBpZiBgc3RyT3JPYmpgIGlzIGEgc3RyaW5nLCBpdCBpcyBwYXNzZWQgdGhyb3VnaCBgSlNPTi5wYXJzZWAgZmlyc3QuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJPck9iaiAtIEEgSlNPTiBzdHJpbmcgb3Igb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgZGVzZXJpYWxpemVkIGNvb2tpZXMuXG4gICAqIEBwYXJhbSBzdG9yZSAtIFRoZSB1bmRlcmx5aW5nIHN0b3JlIHRvIHBlcnNpc3QgdGhlIGRlc2VyaWFsaXplZCBjb29raWVzIGludG8uXG4gICAqL1xuICBzdGF0aWMgZGVzZXJpYWxpemVTeW5jKHN0ck9yT2JqLCBzdG9yZSkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB0eXBlb2Ygc3RyT3JPYmogPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKHN0ck9yT2JqKSA6IHN0ck9yT2JqO1xuICAgIGNvbnN0IHJlYWRTZXJpYWxpemVkUHJvcGVydHkgPSAocHJvcGVydHkpID0+IHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkICYmIHR5cGVvZiBzZXJpYWxpemVkID09PSBcIm9iamVjdFwiICYmIGluT3BlcmF0b3IocHJvcGVydHksIHNlcmlhbGl6ZWQpID8gc2VyaWFsaXplZFtwcm9wZXJ0eV0gOiB2b2lkIDA7XG4gICAgfTtcbiAgICBjb25zdCByZWFkU2VyaWFsaXplZEJvb2xlYW4gPSAocHJvcGVydHkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcmVhZFNlcmlhbGl6ZWRQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiA/IHZhbHVlIDogdm9pZCAwO1xuICAgIH07XG4gICAgY29uc3QgcmVhZFNlcmlhbGl6ZWRTdHJpbmcgPSAocHJvcGVydHkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcmVhZFNlcmlhbGl6ZWRQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUgOiB2b2lkIDA7XG4gICAgfTtcbiAgICBjb25zdCBqYXIgPSBuZXcgX0Nvb2tpZUphcihzdG9yZSwge1xuICAgICAgcmVqZWN0UHVibGljU3VmZml4ZXM6IHJlYWRTZXJpYWxpemVkQm9vbGVhbihcInJlamVjdFB1YmxpY1N1ZmZpeGVzXCIpLFxuICAgICAgbG9vc2VNb2RlOiByZWFkU2VyaWFsaXplZEJvb2xlYW4oXCJlbmFibGVMb29zZU1vZGVcIiksXG4gICAgICBhbGxvd1NwZWNpYWxVc2VEb21haW46IHJlYWRTZXJpYWxpemVkQm9vbGVhbihcImFsbG93U3BlY2lhbFVzZURvbWFpblwiKSxcbiAgICAgIHByZWZpeFNlY3VyaXR5OiBnZXROb3JtYWxpemVkUHJlZml4U2VjdXJpdHkoXG4gICAgICAgIHJlYWRTZXJpYWxpemVkU3RyaW5nKFwicHJlZml4U2VjdXJpdHlcIikgPz8gXCJzaWxlbnRcIlxuICAgICAgKVxuICAgIH0pO1xuICAgIGlmICghamFyLnN0b3JlLnN5bmNocm9ub3VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ29va2llSmFyIHN0b3JlIGlzIG5vdCBzeW5jaHJvbm91czsgdXNlIGFzeW5jIEFQSSBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBqYXIuX2ltcG9ydENvb2tpZXNTeW5jKHNlcmlhbGl6ZWQpO1xuICAgIHJldHVybiBqYXI7XG4gIH1cbiAgLyoqXG4gICAqIEFsaWFzIG9mIHtAbGluayBDb29raWVKYXIuZGVzZXJpYWxpemVTeW5jfS5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogLSBXaGVuIG5vIHtAbGluayBTdG9yZX0gaXMgcHJvdmlkZWQsIGEgbmV3IHtAbGluayBNZW1vcnlDb29raWVTdG9yZX0gd2lsbCBiZSB1c2VkLlxuICAgKlxuICAgKiAtIEFzIGEgY29udmVuaWVuY2UsIGlmIGBzdHJPck9iamAgaXMgYSBzdHJpbmcsIGl0IGlzIHBhc3NlZCB0aHJvdWdoIGBKU09OLnBhcnNlYCBmaXJzdC5cbiAgICpcbiAgICogQHBhcmFtIGpzb25TdHJpbmcgLSBBIEpTT04gc3RyaW5nIG9yIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGRlc2VyaWFsaXplZCBjb29raWVzLlxuICAgKiBAcGFyYW0gc3RvcmUgLSBUaGUgdW5kZXJseWluZyBzdG9yZSB0byBwZXJzaXN0IHRoZSBkZXNlcmlhbGl6ZWQgY29va2llcyBpbnRvLlxuICAgKi9cbiAgc3RhdGljIGZyb21KU09OKGpzb25TdHJpbmcsIHN0b3JlKSB7XG4gICAgcmV0dXJuIF9Db29raWVKYXIuZGVzZXJpYWxpemVTeW5jKGpzb25TdHJpbmcsIHN0b3JlKTtcbiAgfVxufTtcblxuLy8gbGliL2Nvb2tpZS9wZXJtdXRlUGF0aC50c1xuZnVuY3Rpb24gcGVybXV0ZVBhdGgocGF0aCkge1xuICBpZiAocGF0aCA9PT0gXCIvXCIpIHtcbiAgICByZXR1cm4gW1wiL1wiXTtcbiAgfVxuICBjb25zdCBwZXJtdXRhdGlvbnMgPSBbcGF0aF07XG4gIHdoaWxlIChwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBsaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICBpZiAobGluZGV4ID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgbGluZGV4KTtcbiAgICBwZXJtdXRhdGlvbnMucHVzaChwYXRoKTtcbiAgfVxuICBwZXJtdXRhdGlvbnMucHVzaChcIi9cIik7XG4gIHJldHVybiBwZXJtdXRhdGlvbnM7XG59XG5cbi8vIGxpYi9jb29raWUvaW5kZXgudHNcbmZ1bmN0aW9uIHBhcnNlMihzdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIENvb2tpZS5wYXJzZShzdHIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZnJvbUpTT04yKHN0cikge1xuICByZXR1cm4gQ29va2llLmZyb21KU09OKHN0cik7XG59XG5leHBvcnQge1xuICBDb29raWUsXG4gIENvb2tpZUphcixcbiAgTWVtb3J5Q29va2llU3RvcmUsXG4gIFBhcmFtZXRlckVycm9yLFxuICBQcmVmaXhTZWN1cml0eUVudW0sXG4gIFN0b3JlLFxuICBjYW5vbmljYWxEb21haW4sXG4gIGNvb2tpZUNvbXBhcmUsXG4gIGRlZmF1bHRQYXRoLFxuICBkb21haW5NYXRjaCxcbiAgZm9ybWF0RGF0ZSxcbiAgZnJvbUpTT04yIGFzIGZyb21KU09OLFxuICBnZXRQdWJsaWNTdWZmaXgsXG4gIHBhcnNlMiBhcyBwYXJzZSxcbiAgcGFyc2VEYXRlLFxuICBwYXRoTWF0Y2gsXG4gIHBlcm11dGVEb21haW4sXG4gIHBlcm11dGVQYXRoLFxuICB2ZXJzaW9uXG59O1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAyMCwgU2FsZXNmb3JjZS5jb20sIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgU2FsZXNmb3JjZS5jb20gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heVxuICogYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dFxuICogc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tough-cookie/dist/index.js\n");

/***/ })

};
;